00:00:02,000 --> 00:00:14,000
이번 발표는 어제 서울대학교에서 발표했던 “블록체인이 가진 기술적 어려움들”에 관한 내용입니다.


00:00:14,000 --> 00:00:19,000
블록체인은 저장 프로시져가 내장된 오픈 분산 데이터베이스입니다.


00:00:19,000 --> 00:00:25,000
그렇기 때문에 블록체인은 인터넷이나 다른 분산 데이터베이스같은 오픈 네트워크의 특성이 많이 반영되어있습니다.


00:00:25,000 --> 00:00:35,000
예를들면 구글 검색이나  분산형 애플리케이션으로는 구글 독스등과 비슷하다고 할 수 있습니다.


00:00:35,000 --> 00:00:45,000
오픈 네트워크는 누구나 노드를 구축할 수 있고  그렇게 구축한 노드를 다른 노드와 연결시킬 수 있는 네트워크를 말합니다.


00:00:45,000 --> 00:00:50,000
이 노드들은 시스템에 존재하는 다른 서비스들에 접근할 수 있는 권한을 가집니다.


00:00:50,000 --> 00:00:58,000
인터넷은 오픈 네트워크의 단적인 예라고 할 수 있습니다.


00:00:58,000 --> 00:01:04,000
분산장부 혹은 분산 애플리케이션의 예로는 구글 독스를 들 수 있겠습니다.


00:01:04,000 --> 00:01:20,000
구글독스는 많은 사람들이 공동으로 작업하거나 문서에 대한 권한을 얻을 수 있는 앱입니다. 구글독스는 접속중인 모든 노드가 일관된 문서를 제공받을 수 있도록 보증합니다.


00:01:20,000 --> 00:01:35,000
지금 보시는 예제에서는 세명의 참여자가 미국 헌법의 첫 세 단어  We The People을 작성하고 있고  구글독스는 이 세명이 모두 같은 문서를 볼 수 있도록 합니다.


00:01:35,000 --> 00:01:46,000
그런 의미에서 구글독스는 분산 데이터베이스 위에 만들어진 분산 애플리케이션이라고 할 수 있습니다.


00:01:46,000 --> 00:01:57,000
블록체인의 목적중 하나는 완전히 오픈된 네트워크 상에 분산 애플리케이션을 만들 수 있도록 하는 것입니다.


00:01:57,000 --> 00:02:05,000
누구나 애플리케이션을 만들 수 있고  네트워크에 접근할 수 있는 권한을 팔거나 제공할 수 있게끔 말이죠.


00:02:05,000 --> 00:02:15,000
다시 말해 블록체인은 특정 인물이나 회사가 관리하는 네트워크가 아닌  누구나 참여할 수 있는 네트워크라고 할 수 있습니다.


00:02:15,000 --> 00:02:33,000
기존에 나와있는 중앙 관리자가 존재하는 분산 애플리케이션의 형태를 넘어서는 것이 블록체인의 역할이라고 할 수 있겠습니다.


00:02:33,000 --> 00:02:48,000
인터넷은 지역적 비용 모델을 사용합니다. 인터넷 제공업체(ISP)들은 각자 고객들을 가지고 있고  고객들에게 비용을 지불할 때 그 지역의 화폐로 비용을 청구합니다. 이것을 우리는 “지역경제모델” 이라고 합니다.


00:02:48,000 --> 00:03:05,000



00:03:05,000 --> 00:03:13,000
지역경제모델의 문제점은 익히 잘 알려져 있습니다. 예를들면 담합같은 문제점이 있습니다.


00:03:13,000 --> 00:03:32,000
고객들은 자신이 속한 지역에 존재하는 ISP를 통해야만 인터넷에 접속할 수 있는점을 이용해 ISP들은 고객에게 더 높은 사용료를 청구하게끔 담합을 할 수 있습니다.


00:03:32,000 --> 00:03:45,000
또한 ISP의 경우 소비자가 가진 선택지의 폭이 넓지 않기 때문에  애플리케이션 개발자에게 불공정한 비용을 청구하는 등 망 중립성 훼손등의 문제로부터 자유롭지 못할 수 있습니다.


00:03:45,000 --> 00:03:56,000



00:03:56,000 --> 00:04:07,000
조금 비약하자면 지역경제모델은 문제에 대한 해결 방법이 비효율적인 경우가 많습니다.


00:04:07,000 --> 00:04:13,000
예를 들어보겠습니다. 빨간 ISP와 파란 ISP가 있고  origin부터 destination까지 통신을 해야 하는 상황입니다.


00:04:13,000 --> 00:04:23,000



00:04:23,000 --> 00:04:33,000
이 상황에서 가장 효과적인 통신 방법은 빨간 ISP를 통해서 통신하는 것이겠죠.


00:04:33,000 --> 00:04:47,000
하지만 일반적으로 이기적인 ISP들은 전체의 비용 보다는 자신의 비용을 최소화 하려 하기 때문에  빨간색 ISP는 통신 패킷을 자신과 가장 가까운 지점으로 보내버릴 수가 있습니다.


00:04:47,000 --> 00:04:55,000
그 지점은 여기 보이는 파란 ISP와의 교차지점이겠죠.


00:04:55,000 --> 00:05:07,000
결과적으로  빨간 ISP는 비용 절감을 이유로 전체의 사용량이 가장 적어지는 루트를 택하기 보다는 멀리 보내는 쪽을 선택할 것입니다.


00:05:07,000 --> 00:05:28,000
이것은 알고리즘 게임 이론의 전형적인 예시로  시스템에 참여하는 행위자들이 전체의 효율성보다는 자신의 이익을 추구하는 행위가 일반적으로 비효율적인 결과를 만든다는 것을 볼 수 있습니다.


00:05:28,000 --> 00:05:37,000
이 예제에서는 비효율적인 루트를 통함으로서 시스템 전체의 사용량이 낭비되고  결국 시스템에 참여한 행위자들 전체가 사용량과 용량에 불이익을 떠안게 됩니다.


00:05:37,000 --> 00:05:51,000
지역경제모델의 전형적인 한계는 이러한 자원의 효율적 사용이 중요시 될 때 드러납니다.


00:05:51,000 --> 00:05:58,000
블록체인의 경우는 지역경제모델 대신 전체경제모델을 사용합니다.


00:05:58,000 --> 00:06:10,000
블록체인에도 사용자는 지역적으로 존재합니다. 사용자들은 대부분의 경우 자신과 가장 가까운 블록체인 노드에 접속하게 됩니다.


00:06:10,000 --> 00:06:21,000
블록체인의 운영비용역시 지역적인 화폐로 발생합니다. 여기서 운영비용이란 컴퓨터 하드웨어  네트워크 사용량등을 의미합니다.


00:06:21,000 --> 00:06:38,000
하지만 블록체인 내에서의 “서비스 사용료”는 지역 화폐를 통해 발생하지 않습니다. 블록체인에서는 모든 사용자가 비트코인같은 글로벌 화폐로 사용료를 지불하게끔 되어있습니다.


00:06:38,000 --> 00:06:48,000
이러한 전체경제모델의 문제점 역시 서서히 밝혀지고 있습니다.


00:06:48,000 --> 00:07:40,000
비트코인같은 초창기 블록체인의 경우  운영비용은 지역화폐로 발생했지만 서비스에 대한 사용료는 전체화폐인 BTC로 지불되었기 때문에 지역에 따라 수익성에 차이가 있었습니다.


00:07:40,000 --> 00:07:53,000
블록체인의 경우 지역경제모델보다는 전체경제모델을 사용합니다. 사용자의 경우는 여전히 지역적으로 존재하고 운영비용또한 해당 지역 화폐로 발생하지만


00:07:53,000 --> 00:08:06,000
서비스에 대한 사용료는 비트코인과 같은 단일화폐를 사용합니다.


00:08:06,000 --> 00:08:28,000
전체경제모델의 문제점또한 서서히 드러나고 있는데  예를들면 운영비용은 지역화폐로 발생하지만 서비스 사용료는 별도의 글로벌 단일 화폐로 지불되기 때문에


00:08:28,000 --> 00:08:43,000
서비스 운영자가 속한 지역에 따라 수익성에 차이가 날 수 있고  이는 상대적으로 수익성이 좋은 지역에 서비스 운영자들이 모이게 됩니다.


00:08:43,000 --> 00:08:55,000
비트코인을 예로 들자면  많은 비트코인 채굴은 중국에 집중되어있는 형국입니다. 수익성이 높기 때문이죠.


00:08:55,000 --> 00:09:09,000
다른 문제로는 서비스 사용료를 지불하기 위한 화폐를 “만들어야” 한다는 겁니다. 별도의 화폐는 변동성 리스크를 가져올 수 있는데요.


00:09:09,000 --> 00:09:27,000
이는 서비스 운영자가 공격이나 시장 예측 혹은 규제등에 의한 경제적인 변동성을 모두 감안해야 한다는 의미입니다.


00:09:27,000 --> 00:09:31,000
전체시장모델은 이러한 문제점들이 있습니다.


00:09:31,000 --> 00:09:44,000
블록체인에 전체시장모델을 사용하게 된 이유는 순전히 기술적인 이유였습니다.  합의 알고리즘을 수행하려면 내부적으로 코인과 같은 화폐가 필요합니다. 이것에 대해서는 조금 있다 알아보도록 하겠습니다.


00:09:44,000 --> 00:10:05,000
어찌되었든 이 모델들도 기술적인 어려움을 동반합니다. 블록체인의 경우 네트워크가 완전히 공개되어있기 때문에  악의적인 공격을 위한 노드의 생성 및 다른 노드와 접속하는등의 행위가 매우 간단하고


00:10:05,000 --> 00:10:11,000
그 시점엔 시스템 내에 이미 악의적인 노드가 존재할 수 있습니다.


00:10:11,000 --> 00:10:21,000
따라서 블록체인에서의 어려움은  금융 시스템이나 다른 공격처럼 악의적인 침입을 원천 차단하는것과는 다르게


00:10:21,000 --> 00:10:39,000
시스템내에 이미 존재하는 악의적인 노드가 시스템 전체에 악영향을 끼칠 수 없게 방어하고 시스템 내에서 화폐가 도난당하는 것을 방지하는 것 입니다.


00:10:39,000 --> 00:10:54,000
블록체인 애플리케이션은 일반적인 개발자 관점에서 블록체인은 그냥 웹서비스와 다를게 없습니다. JavaScript같은 언어로 클라이언트를 만들고  HTTP를 통해 노드에 접속하고


00:10:54,000 --> 00:11:01,000
노드 상에서 일명 “스마트 컨트랙트” 라고 하는 블록체인 함수를 호출할 수 있습니다.


00:11:01,000 --> 00:11:12,000
앱 개발자 입장에선 이미 흔히 쓰고 있는 여타 앱과 다를게 없어보일 수 있습니다.


00:11:12,000 --> 00:11:30,000
(블록체인 코어) 개발자 관점에서는 좀 복잡합니다. 각기 다른 계층들이 존재하고 해킹이나 공격으로부터 안전하기 위해 별도로 보호를 해야만 합니다.


00:11:30,000 --> 00:11:45,000
블록체인 상에서 발생할 수 있는 문제중 하나를 꼽자면  2개의 애플리케이션이 똑같은 메모리 주소에 서로 다른 값을 쓰려고 한다고 해봅시다.


00:11:45,000 --> 00:11:58,000
중앙형 데이터베이스도 이런 시나리오는 항상 존재합니다. 하지만 중앙형 데이터베이스는 Lock을 통해 접근을 제한함으로써 두 개의 다른 요청을 순차적으로 처리할 수 있습니다.


00:11:58,000 --> 00:12:10,000
위의 예제처럼 두 개의 앱이 Cell X에 메모리 쓰기를 하려 한다면  중앙형 데이터베이스는 하나의 트랜잭션이 끝난 뒤에 다음 트랜잭션을 순차적으로 수행함으로써


00:12:10,000 --> 00:12:16,000
쓰기의 순차성을 보장할 수 있습니다.


00:12:16,000 --> 00:12:30,000
이 예제에서의 문제는 네트워크가 지역적으로 멀리 떨어져 있다는 것입니다. 이 노드는 캘리포니아  저 노드는 일본 도쿄에 있다고 가정해봅시다.


00:12:30,000 --> 00:12:52,000
이쪽 노드에서 데이터베이스 상태 변경이 생김과 동시에  다른쪽 노드에서도 상태 변경이 일어났습니다. 이 경우엔 변경에 대한 정보가 네트워크를 타고 전파되어야 하고  문제점(경합)이 어딘지 규명되어야 합니다.


00:12:52,000 --> 00:12:57,000
경합점이 규명 된 후에는 네트워크상에서 어떤 변경을 취하고 나머지를 버릴것인지에 대한 결정이 내려지게 되고  이 결과를 네트워크 전체에 전파합니다.


00:12:57,000 --> 00:13:10,000
블록체인에서 이러한 경합 접근 문제는 중앙형 데이터베이스에 비해 해결하기가 훨씬 까다롭습니다.


00:13:10,000 --> 00:13:29,000
블록체인에서는 이런 문제를 double spending (이중 지출)이라고 부릅니다. 이예제가 금융  거래였다고 생각해봅시다. 구매자는 자신의 은행 계좌에서 업체의 계좌로 송금을 할 것이고


00:13:29,000 --> 00:13:40,000
동시에 이쪽의 같은 계좌에서 다른 업체로 송금을 하려고 합니다. 하지만 두 업체 모두에게 송금을 하기엔 계좌에 충분한 돈이 존재하지 않으므로


00:13:40,000 --> 00:13:42,000
 둘 중 하나의 송금은 실패해야만 합니다.


00:13:42,000 --> 00:13:48,000
만약 실패하지 않는다면  계좌에 있던 돈의 두배를 지출한 꼴이 되겠죠. 그렇죠?


00:13:48,000 --> 00:14:01,000
다시 말해  앱으로부터 Cell X에 f(4)와 f(3)의 계산값을 쓰고자 하는 요청이 발생하면


00:14:01,000 --> 00:14:11,000
언젠가는 분산 컴퓨팅 레이어에서 이 계산들을 수행하게 됩니다.


00:14:11,000 --> 00:14:24,000
이 두 값들이 계산 된 후에는 “합의 알고리즘”이 필요합니다. 분산 데이터베이스 레이어는 합의 알고리즘을 통해 두 계산 값 (f(3) or f(4))중 어떤 값을 Cell X에 반영할 지 결정하게 됩니다.


00:14:24,000 --> 00:14:38,000
다음 레이어로 가상머신 레이어가 있습니다. 가상머신 레이어는 계산을 수행하는  특히 이 경우엔 f의 계산을 수행하는 레이어입니다.


00:14:38,000 --> 00:14:45,000
더 위에는 언어 레이어가 있습니다. 언어 레이어에서 함수 f의 로직을 정의합니다.


00:14:45,000 --> 00:14:53,000
시스템 코어 개발자의 시선에서 바라본 각 레이어의 설명이었습니다.


00:14:53,000 --> 00:15:05,000
P2P레이어는 제대로 만들기가 상당히 까다로운 레이어입니다. 주로 공격의 타겟이 되는 레이어이기도 합니다.


00:15:05,000 --> 00:15:18,000
사칭이나 메시지 삭제 혹은 위변조  DDoS공격 및 스팸 등 갖가지 공격을 받는 레이어인데요


00:15:18,000 --> 00:15:30,000
시스템에 악의적인 노드를 추가해서 체인 자체를 공격하는것이 그다지 어렵지 않기 때문에  이런 공격들로부터 시스템을 보호하는것은 굉장히 중요한 부분입니다.


00:15:30,000 --> 00:15:53,000
또한 P2P레이어는 많은 양의 메시지가 전달되는 레이어로  자원 요구사항이 높으므로 최적화가 매우 잘 되어있어야 합니다. 이러한 3가지 유형을 잘 만드는것은 일반적으로 매우 어렵다고 여겨지는 부분들입니다.


00:15:53,000 --> 00:16:12,000
테조스도 실수로 인한 버그가 있었습니다. 이 버그는 잘못된 문자열로 인해 발생한 버그였는데  눈으로 보기에는 비어있는 스트링이었지만 사실은 문자열 종료 지시자가 들어있었습니다.


00:16:12,000 --> 00:16:23,000
해커들은 주로 이런 유형의 문제점들을 악용해서 시스템을 다운시키거나  시스템의 계산을 방해함으로써 부당한 이득을 취하려고 합니다.


00:16:23,000 --> 00:16:35,000
다시 말해서 P2P 레이어가 어려운 이유는 그 많은 코드들을 극한으로 최적화 하고  사양 및 설계검토를 통해 코드를 “완전하게” 만들어야 하기 때문입니다.


00:16:35,000 --> 00:16:52,000
즉 이상적인 코드는 최적화가 잘 되어서 자원을 효율적으로 사용하고  만약 사양 변경이 필요할 때에는 잘 짜여진 설계사양을 바탕으로 변경분에 대한 코드를 자동으로 만들어내고


00:16:52,000 --> 00:17:00,000
만들어진 코드의 무결성까지 검사하는 코드라고 할 수 있겠습니다.


00:17:00,000 --> 00:17:20,000
분산 컴퓨팅 레이어에 대한 내용입니다. 요지는  분산 데이터베이스 (체인) 외부에 있는 앱에서 계산을 수행하기 보다는  앱들이 노드에 연결되고 요청을 통해 어떤 계산이 이루어져야 하는지 요청을 하는 것입니다.


00:17:20,000 --> 00:17:31,000
이 계산들은 네트워크에 속한 다른 하위 노드들에 의해 수행이 되고  계산의 결과는 다른 노드들에게 전파됩니다.


00:17:31,000 --> 00:17:52,000
이렇듯 체인 밖의 앱에서 계산을 하지 않고 체인 내의 노드에서 계산을 수행하는 이유는 시스템의 안정성을 높이기 위해서입니다.


00:17:52,000 --> 00:18:08,000
만약 계산을 담당 할 노드가 무작위로 선정된다면  선정 된 노드가 악의적인 목적을 가진 노드일 확률이 매우 낮아지고  이는 곧 시스템의 계산 결과에 대한 악영향을 줄일 수 있겠죠.


00:18:08,000 --> 00:18:22,000
이 측면에서도 여러가지 모델이 있습니다. 가장 안전한 모델은 체인 상의 모든 노드가 같은 계산을 수행하는겁니다.


00:18:22,000 --> 00:18:33,000
이 방법은 굉장히 자원 효율이 낮기 때문에  일반적으로 무작위의 노드들을 선정해서 계산을 수행하게 됩니다.


00:18:33,000 --> 00:18:53,000
노드 선정 과정은 무작위이기 때문에  해커가 미리 자신의 노드가 선정될 지 알 수 없습니다. 즉 혹시 모를 악의적인 공격을 확률적으로 차단한 겁니다.


00:18:53,000 --> 00:19:08,000
물론 진입점에서 계산을 수행할 수도 있습니다. 사실 많은 경우에 진입점은 해커가 점유하고 있지만 이 지점은 독자적인 순수한 데이터베이스를 가지고 있고  그렇기 때문에 계산이 체인 밖에서 이루어지는 것과 같은 효과를 가집니다.


00:19:08,000 --> 00:19:24,000
대부분의 블록체인은 이 모델 (무작위 선정)을 사용합니다. 무작위로 선정 된 노드에서 모든 컨트랙트와 계산이 수행되고  테조스도 같은 방식을 따릅니다.


00:19:24,000 --> 00:19:33,000
분산 컴퓨팅 레이어의 어려운점은 각 알고리즘으로 인한 영향을 이해야한다는 점입니다. 무작위로 선정된 노드들은 크거나 작을 수 있고  성격이 다를 수 있습니다.


00:19:33,000 --> 00:19:49,000
이러한 점들은 전체 네트워크의 쾌적함 혹은 지연등에 영향을 미칠 수 있습니다.


00:19:49,000 --> 00:20:0,000
전체 네트워크 성능을 고려하면서도 높은 보안 수준을 갖추기 위해선 이런 인자들은 매우 세심하게 조절해야 합니다.


00:20:0,000 --> 00:20:20,000
다른 문제점은 이 알고리즘들이 나온지 얼마 되지 않아서 특성이 잘 알려지지 않았따는 점입니다. 이 알고리즘들이 시스템에 어떤 영향을 미치는지에 대한 확실한 증명이 더 있으면 좋겠죠.


00:20:20,000 --> 00:20:41,000
이런 알고리즘들이 이미 레이어 하부에 깊숙이  특히 P2P레이어에 자리잡고 있기 때문에 생기는 어려운점이 있습니다. 컴퓨팅 레이어에 변경이나 실험을 하고싶을 때  만약 P2P 레이어가 설계사양으로부터 자동으로 만들어진 코드였다면  매번 변경사항을 P2P레이어에 직접 반영하지 않아도 됐을 것입니다.


00:20:41,000 --> 00:21:02,000
즉 상위 레이어에서 하위 레이어까지의 코드가 자동으로 변경사항에 맞게 변화할 수 있으면 편하겠죠.


00:21:02,000 --> 00:21:11,000
다음 레이어는 분산 데이터베이스 레이어입니다.


00:21:11,000 --> 00:21:37,000
시스템에는 동시에 2개의 상태가 존재할 수 있습니다. 이 예제에서 보시다시피 네트워크의 일부는 현재 상태를 빨간색(s3)으로 알고 있고  나머지는 파란색(s4)로 알고 있다고 해봅시다.


00:21:37,000 --> 00:22:02,000
이러한 상태는 네트워크를 통해 전파 되다가  언젠가는 시스템의 어느 부분은 두가지의 상태가 공존한다는 것을 알게 될것입니다. 그 시점에 이 프론티어 노드는 현재 상태가 파란색인지 아니면 빨간색인지 결정을 내리고


00:22:02,000 --> 00:22:27,000
시스템 전체의 상태가 하나로 귀결될 때 까지 이 과정은 반복됩니다. 다시 말하면 이 노드 (프론티어 노드)가 현재 상태를 “파란색”으로 결정했다면  인접한 다른 노드들에게 “파란색”의 상태를 전파하고  그 다음엔 이 노드들 역시 “파란색”으로 결정된다면  전체 시스템의 상태는 “파란색”이 될 것입니다. 이것이 합의 알고리즘의 작동 방식입니다.


00:22:27,000 --> 00:22:47,000
하지만 합의 알고리즘도 한계가 있습니다. 불가능성 정리(1985)에 의해 알고리즘이 종료됨과 동시에 모든 노드가 같은 값을 가지며  그 값이 말이 되는 경우는 없다는 것이 설명되었습니다.


00:22:47,000 --> 00:23:00,000
불가능성 정리에 따르면 합의 알고리즘의 이러한 특성 중 하나는 버려야 합니다. 버려도 될만한 유일한 특성은 “종료”입니다.


00:23:00,000 --> 00:23:11,000
달리 말하면 실제 사용되고 있는 합의 알고리즘은 전부 반쪽짜리라는 이야기이고  그 알고리즘들은 종료(완료)되지 않을 수 있습니다. 종종 종료 할 수도 있지만 안 될 수도 있다는 말입니다.


00:23:11,000 --> 00:23:31,000
알고리즘이 종료하지 않기 때문에 네트워크 내에 여러가지의 상태가 공존할 수 있습니다.


00:23:31,000 --> 00:23:41,000
노드들은 한가지 상태 혹은 다른 상태로 천이를 결정할 수 있습니다. 즉 노드의 상태는 시간에 따라 변합니다.


00:23:41,000 --> 00:23:54,000
이 예제에서는 노드 1  5  4는 데이터베이스의 현재 상태가 파란색이라고 생각합니다.


00:23:54,000 --> 00:24:00,000
하지만 노드 2  3은 데이터베이스의 현재 상태가 빨간색이라고 생각하고 있죠.


00:24:00,000 --> 00:24:23,000
언젠가는 프론티어 노드가 데이터베이스 내에 존재하는 빨간색과 파란색 상태에 대해 알게 될것이고  자신의 상태를 바꿀지 아닐지를 결정하게 됩니다. 즉 이 예제에서  노드 2가 파란색으로 천이한 뒤 노드 3도 따라서 파란색으로 천이하면  시스템 전체는 “파란색” 상태를 갖게 됩니다.


00:24:23,000 --> 00:24:48,000
이걸 표현하는 다른 방법도 있습니다. 많은 경우에 이 방법으로 묘사되곤 합니다. 이 그림은 상태의 브랜치를 설명합니다. 최초에는 데이터베이스에 한가지 상태만 존재했지만  어떤 시점에 일부 노드는 파란색 상태를 따르기로 하고  몇몇 노드는 빨간색 상태를 따르기로 합니다.


00:24:48,000 --> 00:24:55,000
빨간 상태의 브랜치는 최초에는 2개의 노드를 가졌지만  하나의 노드(노드2)가 파란색으로 상태를 바꿨고  그 다음에 한개의 빨간 노드가 남아있었지만 이 노드도 파란색으로 상태를 바꾸면서 빨간 브랜치는 사라졌습니다.


00:24:55,000 --> 00:25:25,000
이 그림은 시스템에 여러가지 상태가 하나의 상태로 수렴할 수 있는지 보여줍니다. 노드들이 상태를 바꾸면서 생기는 역학이 브랜치가 없어질 때 까지 끼치는 영향에 대해서 말이죠. 지금은 파란색으로 시스템 전체가 수렴했지만 새로운 상태가 또 생기기도 하겠죠.


00:25:25,000 --> 00:25:45,000
이 그림은 종료하지 않는 알고리즘에 의한 결과입니다. 합의 알고리즘은 종료하지 않을 수 있고  그렇기 때문에 특정 시점에 데이터베이스에는 여러가지의 상태가 공존할 수 있다라는 겁니다.


00:25:45,000 --> 00:26:08,000
여러가지 상태가 공존할 수 있다는걸 알았으니 다른 특성을 추가해봅시다. 장애 허용입니다. 장애허용성엔 일반적으로 2가지 흥미로운 방식이 거론되곤 하는데


00:26:08,000 --> 00:26:30,000
첫번째는 노드의 충돌로 인한 장애를 설명하는 Crash Tolerance가 있고  두번째로는 비정상 메시지를 보내는 등의 악의적인 공격으로부터의 장애 허용성인 Hack Tolerance가 있습니다.


00:26:30,000 --> 00:26:51,000
Hack Tolerance는 비잔틴 실패라고도 합니다. 내장애성을 갖추기 위해서 노드들 사이에서 투표를 진행한 뒤


00:26:51,000 --> 00:26:58,000
다수결에 의해 현재 상태를 정하는 방식입니다.


00:26:58,000 --> 00:27:21,000
아까의 예제로 돌아가보겠습니다. 내장애성을 갖추기 위해서 노드들은 다수결 논리를 따라 “아 파란색 상태가 빨간색 상태보다 더 많구나” “그러니 파란색 상태로 움직이자” 따위의 결정을 합니다.


00:27:21,000 --> 00:27:50,000
이렇게 동작하는 이유는 오로지 소수의 노드만이 해킹을 당했다고 가설을 세웠고  또한 다수결 투표 방식을 따르게 된다면 해킹당한 소수의 의견보단 해킹당하지 않은 다수의 의견으로 결정이 날 것이기 때문입니다.


00:27:50,000 --> 00:28:16,000
그것이 다수결 원칙을 기반으로 한 알고리즘을 사용하는 이유입니다. 일반적으로 “다수결”이라고 할때 50%로는 충분치 않습니다. 기술적으로 1/3 정도가 일반적인 요구사항입니다. 즉 다수결 원칙이 작동하려면 해킹당한 노드가 전체의 1/3이상이 될 수 없습니다.


00:28:16,000 --> 00:28:22,000
만약 해킹당한 노드가 1/3 이상이 된다면 알고리즘이 작동한다고 보장할 수 없습니다.


00:28:22,000 --> 00:28:39,000
어찌되었든 합의 알고리즘은 일종의 투표 메커니즘과 다수결 원칙을 기반으로 작동합니다. 위 설명은 굉장히 기본적인 수준입니다. 정확한 작동방식은 훨씬 더 복잡하지만 본 발표에 넣기엔 내용이 너무 많아 제했습니다.


00:28:39,000 --> 00:28:53,000
폐쇄  네트워크에서는 이러한 것들이 잘 작동합니다. 닫힌 네트워크에서의 합의 알고리즘은 이미 잘 알려져있습니다.


00:28:53,000 --> 00:29:04,000
제일 유명한 알고리즘은 90 년대 Leslie Lamport에 의해 설계된 Paxos입니다.  Paxos는 존재할 수 있는 많은 경우에 대한 유형이 있습니다.


00:29:04,000 --> 00:29:16,000
Paxos는 정형적으로 검증되었습니다. Lamport는 TLA+를 직접 작성했는데


00:29:16,000 --> 00:29:24,000
TLA+는 스펙 언어이면서 모델체커로 동시성이 있는 알고리즘을 검증할 때 사용합니다.


00:29:24,000 --> 00:29:34,000
이러한 툴이 필요한 이유로는  동시성이 있는 알고리즘들은 굉장히 복잡하고 버그가 많기로 유명하기 때문입니다.


00:29:34,000 --> 00:29:48,000
Paxos를 만들고 난 뒤 알고리즘의 특성들을 검증할 수 있는 시스템이 필요했기 때문에 TLA+를 작성한 것이죠.


00:29:48,000 --> 00:29:55,000
이것들은 Paxos 알고리즘의 일반적인 유형들입니다. 비잔틴 실패  순차적 값을 위한 다중 Paxos  시스템 상태가 수렴하기 위해 필요한 라운드 계산 vs pool quorum 등이 있습니다.


00:29:55,000 --> 00:30:10,000
또 약간 심플한 버젼인 Raft도 있습니다. 대체적으로 Paxos의 유형은 많고... 폐쇄 네트워크 세계에서는 어쨌든 Paxos가 가장 잘 알려진 알고리즘입니다.


00:30:10,000 --> 00:30:30,000
폐쇄네트워크란 구글  아마존같이 하나의 관리자가 모든 노드를 관리하고  유한한 노드의 갯수가 알려진 네트워크를 말합니다.


00:30:30,000 --> 00:30:35,000
해킹은 당할 수 있지만 파급은 미미합니다.


00:30:35,000 --> 00:30:48,000
공개 네트워크에서의 합의 알고리즘은 sybli 공격때문에 불가능하다고 여겨졌습니다.


00:30:48,000 --> 00:31:06,000
앞서 설명했다 시피 합의 알고리즘은 투표와 다수결 원칙에 의거해 작동합니다. 폐쇄 네트워크에서는 공격당할 수 있는 노드의 수가 최대 1/3으로 정해져있습니다.


00:31:06,000 --> 00:31:16,000
하지만 투표 결과 다수결에 의해서 해킹당하지 않은 나머지 2/3 의 노드의 결정을 따르겠죠.


00:31:16,000 --> 00:31:36,000
공개 네트워크에서는 악의적인 노드가 얼마든지 생겨날 수 있습니다. 수 백  수 천의 노드를 생성해서 공격자는 쉽게 투표의 결과에 영향을 미칠 수 있습니다.


00:31:36,000 --> 00:31:52,000
즉 문제는 폐쇄형 네트워크의 작동 방식이 공개 네트워크와 호환되지 않는다는 점입니다. 공격자가 많은 노드를 만들어 투표와 다수결 결과를 뒤집으려 할 수 있습니다. 이것이 sybil 공격입니다.


00:31:52,000 --> 00:32:15,000
그렇기 때문에 공개 네트워크에서의 합의 알고리즘은 불가능하다고 여겨져 왔습니다. 적어도 2008년에 Nakamoto가 Bitcoin을 발표하기 전까진 말이죠. Nakamoto의 방법은 완전 다른 종류로  경제적인 인센티브를 발생시킴으로써 문제를 해결했습니다.


00:32:15,000 --> 00:32:29,000
Nakamoto의 합의 알고리즘은 사람들을 네트워크에 참여시키기 위해서 비용을 만들고  합의에 도달할 때 보상을 주는 것입니다.


00:32:29,000 --> 00:32:47,000
시스템에 참여하면서 합의에 도달한 사람들은 본전입니다 (돈을 내고  다시 받아왔으니까요). 하지만 참여만 하고 합의에 도달하지 못한 사람은 손해입니다.


00:32:47,000 --> 00:33:30,000
즉 이를 통해 공격자로부터 “의도적으로 합의에 이르지 않는 행위”를 할 이유를 없애버리는 겁니다. 왜냐면 노드를 만드는 순간 부터 많은 돈을 지불해야 하기 때문이죠.


00:33:30,000 --> 00:33:14,000
다시 말해 공격을 막는다기 보단  공격에 대한 비용을 굉장히 비싸게 만듬으로써 시스템에 대한 공격이 무의미하게끔 만드는 것입니다.


00:33:14,000 --> 00:33:33,000
이것이 Nakamoto의 아이디어고  이것을 알고리즘으로 만들었습니다. Nakamoto의 원래 알고리즘은 proof of work입니다. PoW는 기본적으로 hash function을 역으로 계산하는 암호 퍼즐입니다.


00:33:33,000 --> 00:33:43,000
그리고  합의에 참여하여 암호퍼즐을 풀기 위해서는 고사양의 하드웨어가 필요합니다.


00:33:43,000 --> 00:34:00,000
문제를 풀기 위해 선정 된 무작위 노드들 중 제일 먼저 암호퍼즐을 푼 노드가 계산을 수행할 노드가 됩니다.


00:34:00,000 --> 00:34:05,000
이 특성 역시 미리 예측이 불가능한 무작위성을 만들어냅니다.


00:34:05,000 --> 00:34:23,000
이것이 알고리즘의 pay to participate 부분이 작동하는 방식입니다. 블록을 생성 할 노드가 선정 되면  그 블록 내에 자신의 보상을 추가합니다.


00:34:23,000 --> 00:34:36,000
이 부분이 중요한 부분인데요  방금 만들어진 블록에 보상을 추가하는것이 중요합니다. 왜냐면 그 보상이 합의 알고리즘에 참여해야 하는 실질적인 이유이기 때문이죠.


00:34:36,000 --> 00:34:52,000
이전 이미지로 돌아가보면... 이 사진이요. 블록을 만든 각각의 채굴자들은 블록을 만듬과 동시에 자신의 보상을 블록 내에 남기게 되고


00:34:52,000 --> 00:35:05,000
이 보상은 블록 내에 남겨져 있기 때문에 만약 방금 만들어진 블록을 포함한 브랜치가 사라지게 되면  채굴자들을 위한 모든 보상까지 다 사라지게 됩니다.


00:35:05,000 --> 00:35:21,000
이렇게 브랜치가 날아가서 보상을 받지 못하게 되면 받을 수 있었던 보상을 받지 못하는 꼴이 되므로  채굴자들은 결과적으로 가장 살아남을 가능성이 높은쪽으로 붙으려고 할 것입니다.


00:35:21,000 --> 00:35:37,000
즉 돈을 “잃지 않기 위해서” 채굴자들은 어떤 브랜치가 가장 유력한 생존 후보인지를 찾아내고  그 브랜치를 합의 알고리즘을 통해 유지시키는 방향으로 장려됩니다.


00:35:37,000 --> 00:35:48,000
살아남을 확률이 희박한 브랜치에 블록을 생성해서 이어붙여봤자 돈을 날리는 리스크만 잔뜩 짊어지는 셈이죠.


00:35:48,000 --> 00:36:03,000
이게 알고리즘의 핵심입니다. 채굴자가 채굴을 위해 사용하는 코드를 누가 작성했는지는 중요하지 않습니다. 채굴자가 누구인지도 중요하지 않습니다. 블록을 어떻게 생성하는지도요.


00:36:03,000 --> 00:36:19,000
어떤 상황에서도 채굴자는 자신의 블록이 살아남을 확률이 높은 브랜치에 불록을 생성해서 보상을 받으려고 할 것이고


00:36:19,000 --> 00:36:26,000
이것이 Proof of Work입니다.


00:36:26,000 --> 00:36:40,000
테조스는 Proof of Work알고리즘을 용하지 않습니다. Tezos는 에너지 및 전기가 적게 드는 PoS를 사용합니다. PoS중 Tezos가 사용하는 유형은 Liquid PoS인데요


00:36:40,000 --> 00:36:55,000
이 표가 PoS알고리즘을 간략하게 설명합니다. PoS도 기본은 같습니다만 구현이 살짝 다릅니다. Pay-to-participate  합의 도출 등의 아이디어는 Nakamoto의 PoW아이디어와 같습니다.


00:36:55,000 --> 00:37:04,000
테조스에서는 하드웨어를 사는 대신에 토큰을 소지하여야 합니다; 이 부분이 pay-to-participate 인 것이고요.


00:37:04,000 --> 00:37:22,000
블록을 만드는 노드는 무작위로 선정됩니다. 만약 여러분의 노드가 이번에 블록을 생성하는 노드로 선정 되면  여러분은 소정의 토큰을 일종의 몸값으로 “묻어야” 합니다. 네트워크가 합의에 도달해서 여러분이 블록에 장난을 치지 않았음이 검증될 때 까지요.


00:37:22,000 --> 00:37:47,000
이것이 합의 알고리즘에 참여하는 pay-to-participate 방식입니다. 일정량의 토큰을 보유하고 있어야 하고  또한 합의 알고리즘에 허투루 참여(e.g. 메시지 조작 등 악의적인 행동)을 하면 돈을 잃을 수 있습니다.


00:37:47,000 --> 00:37:58,000
합의에 대한 보상은 PoW와 같이 블럭을 생성할 때 마다 보상을 블럭에 담는 식입니다.


00:37:58,000 --> 00:38:04,000
일정 시간이 지나면 여러분이 묻었던 “몸값”을 다시 돌려받게 됩니다.


00:38:04,000 --> 00:38:29,000
다시 말해: 합의 알고리즘에 돈을 내고 참여하고  합의에 도달하면 보상을 받는 방식입니다. PoW 과 비교하면 몇 가지 다른점이 있습니다. PoS에서는 블록을 생성하는 것이 굉장히 쉽기 때문에  사람들이 다른 많은 브랜치에서 블록을 생성하지 않도록 조심해야 합니다.


00:38:29,000 --> 00:38:45,000
이 알고리즘들은 사람들이 올바른 브랜치를 선택하려 하기 때문에 작동합니다. 브랜치는 잘 골라야 합니다. 조금 돌아가 보면... PoW에서는 어느 브랜치에 블록을 추가할지  골라야 합니다.


00:38:45,000 --> 00:39:03,000
두 브랜치 모두에 추가할 순 없습니다. 비용이 너무 비싸니까요. PoS에서 역시 마찬가지로 신중히 골라야 합니다. 두 브랜치 모두에 블록을 추가할 순 없습니다. 왜냐하면 둘 중 사라지는 브랜치에 묻어둔 “몸값”이 날아가니까요. 이것 때문에 double baking과 bonding mechanism이 존재하는 것입니다.


00:39:03,000 --> 00:39:25,000
전기를 덜 먹는 등 PoS의 이런 세세한 디테일을 제외하면 전반적인 구성과 구현은 PoW와 같습니다. pay-to-particiate  be rewarded for reaching consensus!


00:39:25,000 --> 00:39:40,000
이것이 블록체인과 같은 공개 네트워크에 합의 알고리즘을 적용하기 힘들게 하는 주범인 sybil 공격을 대응한 경제학적인 방법입니다.


00:39:40,000 --> 00:40:03,000
“Nakamoto 추측”은 다른 형태의 합의 알고리즘은 아직까지 발견되지 않았다 라는 추측입니다. 공개 네트워크에서의 합의 알고리즘은 어떤식으로던 “보상”을 필요로 하고  그렇기 때문에 자체적인 화폐를 보유해야 합니다.


00:40:03,000 --> 00:40:26,000
달리 말해 코인이나 토큰을 통한 보상이 없는 합의 알고리즘은 아직까지 찾지 못했다는 것입니다. 모든 블록체인이 자체적인 코인이나 토큰을 가지고 있는 기술적인 이유가 여기에 있습니다.


00:40:26,000 --> 00:40:50,000
흠 좋은 소식은 아닙니다. 왜냐면 블록체인을 통해 이루려던 것은 단순히 개방 된 합의 알고리즘을 가진 데이터베이스인데  화폐를 만들어야 했기 때문입니다. 화폐는 화폐 나름대로 또 다른 문제점들을 야기합니다. 시스템 내에 돈이 존재하다 보니  금융권 시스템 수준의 보안을 갖춰야 하겠죠.


00:40:50,000 --> 00:41:03,000
또한 다른 금융 시스템과도 엮여야 할 필요도 생깁니다. 다시 말해서 이 데이터베이스는 더이상 구글독스같은 간단한 앱을 위한 데이터베이스가 아니라


00:41:03,000 --> 00:41:13,000
복잡성 측면에서 한단계 나아간  금융권의 요구사항을 만족시켜야 하는 “금융 데이터베이스”이 되어버린 것이죠.


00:41:13,000 --> 00:41:30,000
분산 데이터베이스가 가진 어려운 점입니다. 첫번째로 분산 합의 알고리즘을 잘 이해해야 함에 있습니다. 인류는 블록체인을 통해 “작동하기 위해서는 보상이 필요한 합의 알고리즘”을 처음으로 적용해본 것일수도 있습니다.


00:41:30,000 --> 00:41:47,000
경제와 알고리즘이 연관되어있다는 사실은 꽤 오랜기간 알고 있었지만  합의 알고리즘처럼 경제적인 보상 외엔 답이 없는 경우는 이번이 처음입니다.


00:41:47,000 --> 00:42:00,000
아무튼 이렇듯 완전히 새로운 알고리즘이기 때문에 이해도를 높여야 할 필요가 있습니다. 많은 연구와 실험을 통해 더 나은 알고리즘을 설계해야 할 것입니다.


00:42:00,000 --> 00:42:12,000
두번째로는 알고리즘의 특성들에 대한 좀 더 완전한 증명이 있었으면 좋겠다라는 것입니다. Nakamoto 추측이 맞는지 아닌지  즉


00:42:12,000 --> 00:42:23,000
“오 맞아 이런식의 합의 알고리즘이 유일한 방법이야” 혹은 “아냐 코인 없이도 개방 네트워크에서 합의 알고리즘은 가능해” 라는 결론을 내는 것 말이죠.


00:42:23,000 --> 00:42:35,000
이런것들을 대답할 수 있는 지식이 조금 더 있으면 좋을 것입니다. 아직 다른 알고리즘을 전혀 찾지 못했다는 것만 제외하면요.


00:42:35,000 --> 00:42:44,000
여하튼 합의 알고리즘의 특성에 대한 더 많은 증명이 있으면 좋겠습니다. 그것만 있어도 꽤 쓸모 있을겁니다.


00:42:44,000 --> 00:42:59,000
마지막으로  이런 알고리즘은 많은 유기적으로 묶여있는 레이어들로 이루어져 있기 때문에  알고리즘에 수정을 할 때 마다 하부 레이어로 변경사항을 전달해야 합니다.


00:42:59,000 --> 00:43:16,000
이런 변경이 가해질 때 마다 코드가 설계사양으로 부터 자동으로 생성된다면  손으로 코드를 다시 짤 필요 없이 알아서 변경사항이 잘 적용 될 것입니다.


00:43:16,000 --> 00:43:46,000
다음 레이어입니다; 가상머신. 가상머신은 블록체인 해킹의 주된 헛점이라고 할 수 있습니다. 블록체인 자체가 아직 망가지지 않은 이유는 알고리즘의 이유도 있지만  많은 시스템의 상태를 악의적으로 변경하려는 공격은 데이터베이스에 추가된 코드 몇 줄에 의해서 방어 되었습니다.


00:43:46,000 --> 00:44:04,000
만약 스마트 컨트랙트 코드에 버그가 있다면  해커는 그 헛점을 이용해 코인을 훔쳐가거나 정보를 파괴하는등의 공격을 합니다.


00:44:04,000 --> 00:44:10,000
그런 의미에서 가상머신 레이어가 가장 많은 문제를 일으켰습니다.


00:44:10,000 --> 00:44:31,000
그 이유중 한가지는 아마도 초기 블록체인을 위한 가상머신을 설계할 때 보안이 그렇게 중요한 요소가 아니었기 때문일 수도 있습니다. 표준화  이식성  성능  구현의 용이성들이 더 중요했을 수도 있겠죠.


00:44:31,000 --> 00:44:43,000
그래서 - 몇몇가지 가상머신들입니다. EVM과 그것의 기술적인 특징들  WASM  Michelson등이 소개되어 있습니다.


00:44:43,000 --> 00:45:07,000
이 비교에서 한가지 명확한 것인 미켈슨은 프로그래밍을 bug-free 하고 더욱 심플하게 만들기 위해 만들어졌다는 것입니다.


00:45:07,000 --> 00:45:25,000
예를들어서 미켈슨은 infinite precision int 형을 가지고 있습니다. 때문에 미켈슨  개발자는 오버플로우등의 문제를 고려하지 않아도 됩니다. 자료구조 등도 비슷비슷합니다.


00:45:25,000 --> 00:45:35,000
미켈슨은 스마트 컨트랙트 개발자가 조금 더 쉽게 컨트랙트를 만들 수 도록 돕고자 만들어졌습니다. 또한 외부 공격에 취햑하지 않는 컨트랙트를 작성하게끔 돕습니다.


00:45:35,000 --> 00:45:55,000
이더리움이 받았던 공격들의 예제입니다. Ethereum wiki라는 외부 웹사이트이고요  이런 굵직한 돈이 증발 된 사건들의 리스트가 있습니다.


00:45:55,000 --> 00:46:16,000
보시는 것들이 스마트 컨트랙트에 존재할 수 있는 일반적인 버그들입니다. 오버플로우 같은것 들 말이죠. Reentrant 버그 (함수가 다른 함수를 호출하고  서브루틴이 종료되어 돌아올 때  임의의 악의적인 코드가 중간에 수행되는 취약점)는 DAO사태의 원인이었구요.


00:46:16,000 --> 00:46:33,000
그리고 단순히 잘못만든 기능들이 원인일 수도 있습니다. 잘못만든 기능은 아마 손보기가 좀 힘든 버그일 것입니다. 가상머신을 설계할 때에 모든 상황에 대처할 수 있게끔 설계되지 않았고


00:46:33,000 --> 00:46:52,000
많은 경우에 기능을 연계하여 사용 할 경우 잘 동작하지 않는 경우도 많습니다. 하나 하나만 따져보면 좋은 기능이었지만 같이 사용 할 경우 고치기 힘든 문제를 발생시킬 수도 있습니다.


00:46:52,000 --> 00:46:58,000
이런 문제점들은 해킹에 대한 취약점을 만들고  사람들이 돈을 잃어요.


00:46:58,000 --> 00:47:15,000
테조스 가상머신은 스마트 컨트랙트 프로그래밍을 쉽게 만들기 위해 만들어졌습니다. 버그 없는 프로그램을 짜는것은 쉬워야 합니다.


00:47:15,000 --> 00:47:23,000
테조스는 형식 검증을 통해 작성 된 컨트랙트들의 특성을 검증하고  버그가 있는지 확인합니다.


00:47:23,000 --> 00:47:38,000
가상머신은 많은 허들이 있습니다. 가장 큰 허들은 블록체인 자체가 개방형 데이터베이스이고 누구나 코드를 올릴 수 있기 때문인데요


00:47:38,000 --> 00:47:52,000
이 말은 서비스를 사용하는 많은 사용자들이 제3자가 작성한 코드를 실행시키는 경우가 대부분이라는 뜻입니다. 사용자들은 이 코드가 무엇을 할 수 있는지에 대한 확신이 없습니다.


00:47:52,000 --> 00:48:08,000
그래서 사용자들에게 이 제3자가 만든 코드가 무엇을 하는 코드인지 이해할 수 있도록 도움이 필요합니다. 안심하고 써도 된다고 알려줄 수 있어야 하는 것이죠.


00:48:08,000 --> 00:48:22,000
이런것들을 테조스는 형식 검증을 통해 제공합니다. Model checking  abstract interpretation  F-Star와 같은 정리 증명계를 사용하는 것입니다.


00:48:22,000 --> 00:48:34,000
다른 조금 더 간단한 프로그램 같은 경우는 사용 패턴을 조사하고  그것들을 찾아볼 수 있는 검색 엔진을 만드는 것입니다.


00:48:34,000 --> 00:48:54,000
그 다음엔 언어입니다. 언어는 프로그래머에게 가장 인접한 구성요소입니다. 프로그래머들은 이 언어를 사용해서 컨트랙트를 작성하고 가상머신에서 수행하게끔 컴파일 합니다.


00:48:54,000 --> 00:49:18,000
“블록체인은 무엇이다”  “블록체인은 무엇을 해야 한다”와 같은 질문에 모두가 다 똑같은 답을 가지고 있는건 아닙니다. 많은 블록체인 회사들은 블록체인이 구글 독스와 같은 분산형 애플리케이션의 플랫폼이 되어야 한다고 합니다. 그게 무엇이던 간에요.


00:49:18,000 --> 00:49:33,000
테조스를 만드는 개발자들은 그것보단 조금 현실적입니다. 블록체인의 한계 때문인데요. 성능  보안 뭐 그런것들의 한계말입니다.


00:49:33,000 --> 00:49:50,000
테조스 개발자들은 조금 더 천천히 한 단계씩 나아가야 한다고 생각합니다. 첫번째로 비교적 간단한 송금 처리가 필요한 법적 계약 같은것을 자동화 할 수 있어야 한다고 생각하고요.


00:49:50,000 --> 00:50:04,000
그래서 구글독스 같은 앱을 만들기 보다는 훨씬 간단한 앱을 만들어야 할 것입니다. 이를테면 자동 송금이라던지..


00:50:04,000 --> 00:50:33,000
에스크로 시스템이나  회사와 프리랜서 간 비용 지불을 위한 시스템등도 좋습니다. 이런것들이 제대로 만들어지고 돌아가는 상태에서  시스템이 안전하고  오랜 기간동안 문제 없이 작동하고 난 후에야 조금 더 포괄적인 앱들을 생각해볼 수 있겠습니다.


00:50:33,000 --> 00:50:52,000
컨트랙트 자체도 “무엇이어야 한다”라는 질문에 많은 답이 있습니다. 어떤 애플리케이션이 블록체인에서 수행되어야 하는지에 대해서 말이죠. 이런 다른 견해로 인해 컨트랙트를 구성하는 언어는 어떤것이 적합한지에 대해서도 많은 견해차가 있습니다.


00:50:52,000 --> 00:51:03,000
테조스는 스마트 컨트랙트는 DSL로 작성된 심플한 법적 계약등이 스마트 컨트랙트가 되어야 한다고 생각합니다.


00:51:03,000 --> 00:51:14,000
컨트랙트들의 특성을 파악하고 검증함으로서 전반적으로 더욱 견고한 시스템을 만들 수 있고  이런 컨트랙트들 역시 전문가에 의해서 작성되어야 할 것입니다.


00:51:14,000 --> 00:51:33,000
테조스 사람들은 JavaScript를 건드리는 웹개발자가 있고  컨트랙트를 짜는 다른 전문가가 있어야 한다고 생각합니다. 형식 검증이나 관련된 검증툴에 대한 이해를 가진 회사들 말이죠.


00:51:33,000 --> 00:51:38,000
그리고 정말 정말 전문가에게 코어 개발을 맡기고요.


00:51:38,000 --> 00:51:58,000
다른 블록체인의 경우 스마트 컨트랙트는 보편적이고  포괄적이고  그렇기 때문에 더 JavaScript나 Python같은 일반적인 언어로 작성되어야 한다고 생각합니다.


00:51:58,000 --> 00:52:13,000
언어와 가상머신이 어떻게 만들어졌냐에 따른 결과를 낳게 됨에 있어서 블록체인 개발사간 입장 차이는 발생할 수 밖에 없습니다.


00:52:13,000 --> 00:52:28,000
테조스는 체인 밖에서 계산될 수 있는것들은 모두 체인 밖에서 계산되도록 권고합니다. 왜냐면 블록체인은 느리거든요.


00:52:28,000 --> 00:52:47,000
블록체인의 속도 자체는 개선의 여지가 있으나  아무리 개선을 해도 컴퓨터가 직접 계산을 수행하는 것 만큼 빨라질 순 없습니다. 블록체인은 느리기 때문에 체인 상에서 무엇을 수행해야 하는지에 대해 조금 조심스럽게 접근해야 합니다.


00:52:47,000 --> 00:53:03,000
여기 아주 간단한 예제가 있습니다. 같은 일을 하는 올바른 방법이 있고  잘못된 방법이 있습니다. 이 앱은 단순히 스마트 컨트랙트를 인자 9로 호출하는것 외엔 하는게 없습니다.


00:53:03,000 --> 00:53:15,000
컨트랙트 자체도 유일하게 하는 것이라곤 9의 제곱근을 구하는 것 뿐입니다. 결과적으로 f(9)의 스마트 컨트랙트 호출을 하면  함수는 3을 반환하겠죠.


00:53:15,000 --> 00:53:42,000
이 방법은 잘못 된 방법입니다. 왜냐하면 블록체인에게 “복잡한” 계산인 제곱근 계산을 요청했기 때문입니다.


00:53:42,000 --> 00:53:53,000
블록체인은 굉장히 느립니다. 그렇기 때문에 테조스에서는 체인 밖에서 계산될 수 있는 것들은 체인 밖에서 계산하도록 권고하고 있습니다.


00:53:53,000 --> 00:54:09,000
여기 아주 간단한 예제가 있습니다. 같은 일을 하는 올바른 방법이 있고  잘못된 방법이 있습니다. 이 앱은 스마트 컨트랙트 요청을 날리고  스마트 컨트랙트는 인자의 제곱근을 구합니다.


00:54:09,000 --> 00:54:22,000
앱이 컨트랙트 함수 f를 인자 9로 호출하면서  스마트 컨트랙트에서 제곱근을 계산했습니다. 하지만 이것은 잘못된 방법입니다.


00:54:22,000 --> 00:54:31,000
왜냐면 블록체인은 느리고  그런 느린 시스템에 제곱근을 계산하도록 요청했기 때문입니다. 체인 상에서는 훨씬 더 간단한 것들이 수행되어야 합니다.


00:54:31,000 --> 00:54:42,000
그래서 - 올바른 방법은  제곱근은 체인 밖에서 계산하고  블록체인을 이용해서 제곱근이 잘 계산되었는지 증명할 수 있습니다.


00:54:42,000 --> 00:54:58,000
다시 말하면 컨트랙트 요청을 할 때 9와 9의 제곱근인 3을 같이 인자로 요청하고  블록체인은 역으로 3*3 = 9가 나오는지 확인한 뒤  값이 맞다면 최종 값 3을 사용하면 됩니다.


00:54:58,000 --> 00:55:12,000
차이점은 첫번째 예제에서는 제곱근 계산을 굉장히 느린 부분인 블록체인의 가상머신에서 수행하고 있고  두번째 예제에서는 단순한 곱셈 연산만을 수행하고 값이 같은지 체크합니다.


00:55:12,000 --> 00:55:32,000
이것이 바로 올바른 방법입니다. 체인 밖에서 계산 될 수 있는 모든것들은 체인 밖으로 내보내고  블록체인 상에서는 최소한의 검증만 하는 것이고  잘못된 방법은 블록체인이 복잡한 계산을 하게 하는 것이죠


00:55:32,000 --> 00:55:45,000
그래서 테조스는 최대한 많은 연산을 체인 밖으로 빼기를 권장합니다.


00:55:45,000 --> 00:56:02,000
언어: 언어 생태계와 구성에 대해 설명하겠습니다. 여기 다른 언어들이 있는데  이 언어들은 모두 미켈슨으로 컴파일 되는 언어들입니다.


00:56:02,000 --> 00:56:13,000
아직 초기 상태의 언어들이고 컴파일러도 완성되지 않았지만 어쨌든 mini OCaml  mini Haskell  mini Javascript 그리고 mini Python이 있습니다. 이 언어들은 모두 미켈슨으로 컴파일 됩니다.


00:56:13,000 --> 00:56:27,000
지금 현재로써는 4개의 별도 컴파일러가 있고요. 향후에는 DSL도 추가 될 예정입니다. 전체적인 문제가 있다면 이 모든 컴파일 단계가 블록체인의 비용 모델을 이해해야 한다는 점입니다.


00:56:27,000 --> 00:56:36,000
블록체인에서 비용은 메모리  절차 수행에 의해 발생됩니다. (그렇기 때문에 더더욱 복잡한 계산은 체인 밖으로 빼야겠죠?)


00:56:36,000 --> 00:56:45,000
또한 형식검증도 수행해야 하고  model checking  abstract interpretation  theorem provers 등…


00:56:45,000 --> 00:56:59,000
상위언어로 작성한 이 모든 측면이 미켈슨으로 짠 코드와 같아지도록 컴파일러가 인증되고 검증되어야 합니다.


00:56:59,000 --> 00:57:08,000
테조스의 컴파일 시스템이 어떻게 작동하는지 보셨습니다.


00:57:08,000 --> 00:57:19,000
숙제들입니다. 언어 레이어의 숙제는 체인상의 프로그램들이 사용자의 기대와 일치하도록 만드는 것입니다.


00:57:19,000 --> 00:57:38,000
앞서 얘기한 사용자는 대부분의 시간을 제3자가 작성한 코드를 사용한단 말 기억하시나요? 그렇기 때문에 사용자는 이 프로그램을 사용하는것이 안전한지  악의적인 코드는 아닌지 알아야만 합니다.


00:57:38,000 --> 00:57:59,000
언어 레이어에서는 이런 부분이 아마 가장 어렵지 않을까 싶습니다. 사용자들이 언어 체계를 이해하게 만드는  사용자들이 사용하는 컨트랙트의 내용이 무엇인지 이해하게끔 만드는 것 말이죠. 직접 쓴 컨트랙트이던 제3자가 썼던간에요.


00:57:59,000 --> 00:58:20,000
두번째 숙제는 컨트랙트 마다 특정되는 속성들을 검증하는 것입니다. 세번째로는 컴파일 시스템을 e2e로 검증하는 일일테고요. 그 다음엔 특정 컨트랙트 분류마다의 DSL입니다.


00:58:20,000 --> 00:58:38,000
예를들면 금융거래를 위한 DSL  혹은 간단한 계약 관계를 위한 DSL등  뭐든지 있을 수 있습니다.


00:58:38,000 --> 00:58:48,000
다른 어려운점은 개발자들이 블록체인 개발을 할 수 있는 환경을 만들고  블록체인의 비용 모델을 이해하게끔 하는 일입니다.


00:58:48,000 --> 00:58:56,000
블록체인은 다른 프로그래머들이 일반적으로 익숙한 분야와는 조금 다른 분야입니다.


00:58:56,000 --> 00:59:04,000
운영 비용이 다르겠죠 - 메모리  체인에서 계산해야 할지 밖으로 빼야할지 등등등.


00:59:04,000 --> 00:59:16,000
그래서 만약 개발자들이 이런 결정을 쉽게 할 수 있는 개발 환경이 있고 이를 통해 컨트랙트 작성이 쉬워진다면 좋을것입니다.


00:59:16,000 --> 00:59:32,000
다음입니다. 앞서 블록체인은 금융 시스템에 버금가는 보안 수준을 갖춰야 한다고 했습니다. 이 보안의 많은 부분은 암호로 이루어져 있습니다.


00:59:32,000 --> 00:59:42,000
테조스는 검증된 암호화 체계를 사용합니다. 그렇기 때문에 암호학적 산출물이 버그나 다른 문제를 야기하지 않습니다.


00:59:42,000 --> 00:59:52,000
테조스가 사용하는 암호 체계는 필요한 요구사항에 대해 F*등의 툴로 이미 검증이 되었습니다.


00:59:52,000 --> 01:00:04,000
보안의 다른 부분은 무기명 송금을 하면서도 다른 외부 시스템과 상호작용하는 것입니다.


01:00:04,000 --> 01:00:10,000
이러한 외부 시스템과의 상호작용은 zero-knowledge proofs라는 것으로 동작이 보장됩니다.


01:00:10,000 --> 01:00:30,000
Zero knowledge proof는 설명하기 조금 까다롭습니다. 마치 여러분이 저에게 아무 디테일도 말하지 않고 무언가 했다고 증명하는 것입니다.


01:00:30,000 --> 01:00:51,000
연산을 했다는 증명  혹은 돈을 좀 썼는지 따위의 증명이 있죠. Visa카드를 생각해봅시다. 여러분은 Visa 카드를 사용해서 물건값을 지불합니다. Visa가 여러분의 계좌에서 돈을 가져갈 때  여러분이 실제로 사용한 카드 사용분 만큼 정확한 계산을 해서 돈을 가져갔음을 증명할 수 있습니다.


01:00:51,000 --> 01:00:59,000



01:00:59,000 --> 01:01:08,000



01:01:08,000 --> 01:01:33,000
여기까지는 Visa의 증명 시스템에 관한 내용입니다. 만약 Visa 시스템이 블록체인와 상호작용해야 한다면  이 증명들에서 중요한 정보는 가려져야 할것입니다. Visa사는 블록체인에 거래의 종류나 누구의 거래인지 등등의 정보를 남기고 싶지 않을테니까요.


01:01:33,000 --> 01:01:43,000
Visa는 그런 정보를 주지 않고도 셈을 잘 했다고 증명할 수 있어야 합니다. 이것이Zero knowledge proof입니다.


01:01:43,000 --> 01:01:56,000
최근 기술로는 SNARKs  STARKs등이 있고 다른 많은 유형들이 있습니다. 중요한점은 zero knowledge proof는 아직 연구의 초기단계라는 점입니다.


01:01:56,000 --> 01:02:10,000
여기 나온 최첨단 기술들은 수학적으로 엄청나게 복잡한 시스템입니다. 이것들이 제대로 작동하게 하기 위해서는 많은 연구와 컴퓨팅 파워가 필요합니다.


01:02:10,000 --> 01:02:17,000
네 그래서... 아직은 연구중인 부분입니다.


01:02:17,000 --> 01:02:29,000
블록체인과 다른 금융 시스템과의 안전한 연계는 이런 암호체계를 통해 이루어집니다.


01:02:29,000 --> 01:02:43,000
연결은 언제든지 할 수 있겠지만  만약 진짜 연결을 한다면 대상 금융 시스템이 블록체인 만큼 안전해야 할 것입니다. 그렇지 않으면 또 다른 공격의 거점이 되니까요.


01:02:43,000 --> 01:02:59,000
Zero-knowledge proof는 이런 용도로 사용됩니다. Zero-knowledge proof의 숙제는 양 단간 보증 된 zero-knowledge proof를 만드는 것일겁니다.


01:02:59,000 --> 01:03:07,000
다른 숙제로는 오늘날의 zero knowledge proof는 보편적이기 때문에 굉장히 복잡한 특성을 나타냅니다.


01:03:07,000 --> 01:03:16,000
도메인별로 특화 된 zero knowledge proof가 있으면  필요한 연산이 훨씬 효율적이고 간단할 것입니다. 아주 간단한 zero knowledge proof정도만 수행 하겠지만요. 이상적으로는 효율적인 zero knowledge proof가 더 좋은 방법입니다.


01:03:16,000 --> 01:03:43,000
이 모든것들이 다 숙제로 남아있습니다. 이 숙제들은 연구적 가치가 있는 질문들이지만 아직 답은 찾지 못했습니다. 특히 zero knowledge proofs에 관해서는 말이죠.


01:03:14,000 --> 01:03:50,000
이상으로 마치겠습니다. 질문 있으신 분?
