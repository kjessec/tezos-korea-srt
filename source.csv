time,English,Korean
0:00:02,So this is a presentation about a technical challenges of the blockchain  that was presented yesterday at the Seoul National University  and we’re recording now.,이번 발표는 어제 서울대학교에서 발표했던 “블록체인이 가진 기술적 어려움들”에 관한 내용입니다.
0:00:14,blockchains are open distributed databases with stored procedures ,블록체인은 저장 프로시져가 내장된 오픈 분산 데이터베이스입니다.
0:00:19,and in that sense they inherit of the properties of open networks like the internet  of distributed databases,그렇기 때문에 블록체인은 인터넷이나 다른 분산 데이터베이스같은 오픈 네트워크의 특성이 많이 반영되어있습니다.
0:00:25,typical examples are Google search  and of distributed applications  things like Google Docs.,예를들면 구글 검색이나  분산형 애플리케이션으로는 구글 독스등과 비슷하다고 할 수 있습니다.
0:00:35,An open network is a network in which anyone can set up a node and can link that node to other nodes of the system,오픈 네트워크는 누구나 노드를 구축할 수 있고  그렇게 구축한 노드를 다른 노드와 연결시킬 수 있는 네트워크를 말합니다.
0:00:45, and can provide access to the system and to the services that are in the system.,이 노드들은 시스템에 존재하는 다른 서비스들에 접근할 수 있는 권한을 가집니다.
0:00:50,internet is a typical example of permission (?) for open networks,인터넷은 오픈 네트워크의 단적인 예라고 할 수 있습니다.
0:00:58,then distributed databases. an example of distributed database or distributed application is Google Docs.,분산장부 혹은 분산 애플리케이션의 예로는 구글 독스를 들 수 있겠습니다.
0:01:04,Google Docs is an application in which a multiple people can collaborate and right to get a document   and the system will make sure that the document is consistent across all the nodes that are accessing to it.,구글독스는 많은 사람들이 공동으로 작업하거나 문서에 대한 권한을 얻을 수 있는 앱입니다. 구글독스는 접속중인 모든 노드가 일관된 문서를 제공받을 수 있도록 보증합니다.
0:01:20,in this example we have three people are writing the three first words of the America Constitution  We the People  then you have Google Docs that will make sure that they all see the same thing  the same document.,지금 보시는 예제에서는 세명의 참여자가 미국 헌법의 첫 세 단어  We The People을 작성하고 있고  구글독스는 이 세명이 모두 같은 문서를 볼 수 있도록 합니다.
0:01:35,In that sense it’'s a distributed database  on top of which is built and distributed application  in this case the editing application.,그런 의미에서 구글독스는 분산 데이터베이스 위에 만들어진 분산 애플리케이션이라고 할 수 있습니다.
0:01:46, Now  the main promise of blockchain is to be able to create distributed applications on a network that is completely open.,블록체인의 목적중 하나는 완전히 오픈된 네트워크 상에 분산 애플리케이션을 만들 수 있도록 하는 것입니다.
0:01:57, so anyone can create an application  and anyone can provide and sell an access to the network.,누구나 애플리케이션을 만들 수 있고  네트워크에 접근할 수 있는 권한을 팔거나 제공할 수 있게끔 말이죠.
0:02:05,in that sense  it's a system in which the network itself is not controlled by a single actor  but anyone can participate.,다시 말해 블록체인은 특정 인물이나 회사가 관리하는 네트워크가 아닌  누구나 참여할 수 있는 네트워크라고 할 수 있습니다.
0:02:15,So the promise of blockchain in basically to break the existing systems in which a single actor is the one that manages all the nodes  on top of which are these distributed applications.,기존에 나와있는 중앙 관리자가 존재하는 분산 애플리케이션의 형태를 넘어서는 것이 블록체인의 역할이라고 할 수 있겠습니다.
0:02:33,Now internet uses a local cost model  which means that the internet service providers  the organizations that provide access to services that are internet  ,인터넷은 지역적 비용 모델을 사용합니다. 인터넷 제공업체(ISP)들은 각자 고객들을 가지고 있고  고객들에게 비용을 지불할 때 그 지역의 화폐로 비용을 청구합니다. 이것을 우리는 “지역경제모델” 이라고 합니다.
0:02:48, they have local customers  they operate with local costs  they are paid for their services locally  and all those exchanges are done in local currency. that's what we understand by “Local economic model”.,
0:03:05,And the problem of the local economic model is that it has limitations that are all well known now ,지역경제모델의 문제점은 익히 잘 알려져 있습니다. 예를들면 담합같은 문제점이 있습니다.
0:03:13, which are for example cartels. because the customers can only access service providers that are within their economic region. Then these actors  can agree together to keep prices high for instance. so that's an example of the Cartel.,고객들은 자신이 속한 지역에 존재하는 ISP를 통해야만 인터넷에 접속할 수 있는점을 이용해 ISP들은 고객에게 더 높은 사용료를 청구하게끔 담합을 할 수 있습니다.
0:03:32,other example of limitations of this network is the fact that again because the customers are captive from this access service providers  then they can destroy the competition,또한 ISP의 경우 소비자가 가진 선택지의 폭이 넓지 않기 때문에  애플리케이션 개발자에게 불공정한 비용을 청구하는 등 망 중립성 훼손등의 문제로부터 자유롭지 못할 수 있습니다.
0:03:45, and they can ask application builders  companies that do the applications to pay for access to these customers. that's what's happening with the problems of net neutrality,
0:03:56,and marginally speaking  we know that this local economic model creates situations in which the solutions that are found are suboptimal.,조금 비약하자면 지역경제모델은 문제에 대한 해결 방법이 비효율적인 경우가 많습니다.
0:04:07, so there an example of these very simple case that we have here,예를 들어보겠습니다. 빨간 ISP와 파란 ISP가 있고  origin부터 destination까지 통신을 해야 하는 상황입니다.
0:04:13, in here we have two ISP  red ASP in the blue ISP  and there is a communication that wants to go from origin to destination.,
0:04:23, the optimal way of routing that communication is to.. that Communications completely route through the red ISP.,이 상황에서 가장 효과적인 통신 방법은 빨간 ISP를 통해서 통신하는 것이겠죠.
0:04:33,however because network operators tend to be selfish and try to minimize their cost  not the global cost of the system  in this case the red ISP is probably going to send that communication to the closest point outside of its Network ,하지만 일반적으로 이기적인 ISP들은 전체의 비용 보다는 자신의 비용을 최소화 하려 하기 때문에  빨간색 ISP는 통신 패킷을 자신과 가장 가까운 지점으로 보내버릴 수가 있습니다.
0:04:47, and that's this blue intersection point. and as a result instead of taking the shortest path ,그 지점은 여기 보이는 파란 ISP와의 교차지점이겠죠.
0:04:55,which would have been the one that globally minimizes the bandwidth  it’s going to be taking a longer path  just because the red operator is selfish and want to minimize his cost.,결과적으로  빨간 ISP는 비용 절감을 이유로 전체의 사용량이 가장 적어지는 루트를 택하기 보다는 멀리 보내는 쪽을 선택할 것입니다.
0:05:07, so those are typical problems in algorithmic game theory is that the systems  or the subset of actors that at the same time for optimizing their own profit  not the profit  of  not optimize the whole system  tend to end in suboptimal situations like this one.,이것은 알고리즘 게임 이론의 전형적인 예시로  시스템에 참여하는 행위자들이 전체의 효율성보다는 자신의 이익을 추구하는 행위가 일반적으로 비효율적인 결과를 만든다는 것을 볼 수 있습니다.
0:05:28, and that waste is bandwidth for the whole system. using paths that are longer than what they could be means that everyone is going to suffer for my reduced capacity in the system,이 예제에서는 비효율적인 루트를 통함으로서 시스템 전체의 사용량이 낭비되고  결국 시스템에 참여한 행위자들 전체가 사용량과 용량에 불이익을 떠안게 됩니다.
0.05:37,and so those are typical limitations of a local economic model  a problem of optimization of resources.,지역경제모델의 전형적인 한계는 이러한 자원의 효율적 사용이 중요시 될 때 드러납니다.
0:05:51,Blockchains have decided to use a different model which is a global model.,블록체인의 경우는 지역경제모델 대신 전체경제모델을 사용합니다.
0:05:58,They continue using  having a local customers. Customers are connected to the closest entry point to the blockchain  which is most of the time nearby entry point ,블록체인에도 사용자는 지역적으로 존재합니다. 사용자들은 대부분의 경우 자신과 가장 가까운 블록체인 노드에 접속하게 됩니다.
0:06:10,The operation cost by the blockchain operators are still incurred in local currency. The operation costs are things like the hardware  bandwidth  things like that,블록체인의 운영비용역시 지역적인 화폐로 발생합니다. 여기서 운영비용이란 컴퓨터 하드웨어  네트워크 사용량등을 의미합니다.
0:06:21, but the payment of the services that are provided in blockchain is done at a global scale. so it's the same payment for for everyone and it's all done  in a Global Currency  in this case the currency of the system  for instance  Bitcoin.,하지만 블록체인 내에서의 “서비스 사용료”는 지역 화폐를 통해 발생하지 않습니다. 블록체인에서는 모든 사용자가 비트코인같은 글로벌 화폐로 사용료를 지불하게끔 되어있습니다.
0:06:38,So in that sense it’s a global economic model  and the limitations of the global economic models are also being progressively understood.,이러한 전체경제모델의 문제점 역시 서서히 밝혀지고 있습니다.
0:06:48,one limitation that is very visible in early blockchains like Bitcoin is the fact that because there is the costs are incurred locally  but the payment is global there was a difference in profitability and depending on the economic area,비트코인같은 초창기 블록체인의 경우  운영비용은 지역화폐로 발생했지만 서비스에 대한 사용료는 전체화폐인 BTC로 지불되었기 때문에 지역에 따라 수익성에 차이가 있었습니다.
0:07:40,blockchains have decided to operate according to a global economic model. they continue having local customers and their operation costs are incurred locally ,블록체인의 경우 지역경제모델보다는 전체경제모델을 사용합니다. 사용자의 경우는 여전히 지역적으로 존재하고 운영비용또한 해당 지역 화폐로 발생하지만
0:07:53, but the payment of the services are done at a global scale  with a global cost for the same for all operators and with a Global Currency  for instance Bitcoin.,서비스에 대한 사용료는 비트코인과 같은 단일화폐를 사용합니다.
0.08.06, so the limitations of the global economic model are starting to appear progressively. for instance the difference between.. there's a difference of profitability between the operators due to the fact that they incur local costs but they have Global Payments for the services ,전체경제모델의 문제점또한 서서히 드러나고 있는데  예를들면 운영비용은 지역화폐로 발생하지만 서비스 사용료는 별도의 글로벌 단일 화폐로 지불되기 때문에
0.08.28, and as a result some Geographic areas are more profitable than others  which will end in having a concentration of operators in the traffic areas that are more profitable.,서비스 운영자가 속한 지역에 따라 수익성에 차이가 날 수 있고  이는 상대적으로 수익성이 좋은 지역에 서비스 운영자들이 모이게 됩니다.
0.08.43,that's what we see with Bitcoin  where many Bitcoin miners are concentrating in China. Due to the higher profitability.,비트코인을 예로 들자면  많은 비트코인 채굴은 중국에 집중되어있는 형국입니다. 수익성이 높기 때문이죠.
0.08.55, The second problem of this global economic models is that they have to create a separate currency in order to pay for all the services  and this separate currency creates risks of fluctuations ,다른 문제로는 서비스 사용료를 지불하기 위한 화폐를 “만들어야” 한다는 겁니다. 별도의 화폐는 변동성 리스크를 가져올 수 있는데요.
0.09.09,so Financial Risk for the system operators and they also create risks related to attacks  spams  speculation and other regulation that comes with that,이는 서비스 운영자가 공격이나 시장 예측 혹은 규제등에 의한 경제적인 변동성을 모두 감안해야 한다는 의미입니다.
0.09.27,So the global model also has the limitations.,전체시장모델은 이러한 문제점들이 있습니다.
0.09.31,one of the reasons why the blockchains have chosen to work with a global model is also a purely technical  because in order to operate the algorithm  the consensus algorithms  need to have an internal coin but we will see that little bit later.,블록체인에 전체시장모델을 사용하게 된 이유는 순전히 기술적인 이유였습니다.  합의 알고리즘을 수행하려면 내부적으로 코인과 같은 화폐가 필요합니다. 이것에 대해서는 조금 있다 알아보도록 하겠습니다.
0.09.44,In any case those models also create technical challenges  which is that because the system is completely open then it's very easy for attackers to just join the system to just a create their own nodes ,어찌되었든 이 모델들도 기술적인 어려움을 동반합니다. 블록체인의 경우 네트워크가 완전히 공개되어있기 때문에  악의적인 공격을 위한 노드의 생성 및 다른 노드와 접속하는등의 행위가 매우 간단하고
0.10.05, Connect their  nodes to the rest of the system and they’re now within the system.,그 시점엔 시스템 내에 이미 악의적인 노드가 존재할 수 있습니다.
0.10.11,So unlike other attacks  or the Financial systems where the Challenges are more to prevent intrusions  in this case that attacks are already inside.,따라서 블록체인에서의 어려움은  금융 시스템이나 다른 공격처럼 악의적인 침입을 원천 차단하는것과는 다르게
0.10.21, so the problem is to prevent those nodes that are owned by attackers to disturb the computations of the database  and also to prevent users of the system  from stealing currency from that system.,시스템내에 이미 존재하는 악의적인 노드가 시스템 전체에 악영향을 끼칠 수 없게 방어하고 시스템 내에서 화폐가 도난당하는 것을 방지하는 것 입니다.
0.10.39,So  from the application side that is from the everyday’s programmer side point of view  the blockchain is just a web service. So you have your application written in whatever language you want  JavaScript  that connects to a node via HTTP ,블록체인 애플리케이션은 일반적인 개발자 관점에서 블록체인은 그냥 웹서비스와 다를게 없습니다. JavaScript같은 언어로 클라이언트를 만들고  HTTP를 통해 노드에 접속하고
0.10.54,and calls functions  which here in this case are called smart contracts for the blockchain   that reside in this node.,노드 상에서 일명 “스마트 컨트랙트” 라고 하는 블록체인 함수를 호출할 수 있습니다.
0.11.01,From the application developer it looks just like a web service similar to any other web service that they might be currently using.,앱 개발자 입장에선 이미 흔히 쓰고 있는 여타 앱과 다를게 없어보일 수 있습니다.
0.11.12,From the developers' perspective the system is significantly more complex  and has different layers that need to be protected  separately protected to avoid attacks and hacks.,(블록체인 코어) 개발자 관점에서는 좀 복잡합니다. 각기 다른 계층들이 존재하고 해킹이나 공격으로부터 안전하기 위해 별도로 보호를 해야만 합니다.
0.11.30,The typical example of a problematic case in a blockchain is when there are 2 applications that run to write in the same memory cell to different values.,블록체인 상에서 발생할 수 있는 문제중 하나를 꼽자면  2개의 애플리케이션이 똑같은 메모리 주소에 서로 다른 값을 쓰려고 한다고 해봅시다.
0.11.45, this is the case also for centralized databases  is but what happens in centralized database is the Central database usually manages the different access to it via locks  and make sure that they're sequential.,중앙형 데이터베이스도 이런 시나리오는 항상 존재합니다. 하지만 중앙형 데이터베이스는 Lock을 통해 접근을 제한함으로써 두 개의 다른 요청을 순차적으로 처리할 수 있습니다.
0.11.58,so if two applications want to write in a central database and they want to write on the Cell X  1 value here in another value here ,위의 예제처럼 두 개의 앱이 Cell X에 메모리 쓰기를 하려 한다면  중앙형 데이터베이스는 하나의 트랜잭션이 끝난 뒤에 다음 트랜잭션을 순차적으로 수행함으로써
0.12.10,the central database  only thing that is going to do is that it is going to make one transaction pass and once the transaction has ended and the second transaction is going to scheduled. In sequence.,쓰기의 순차성을 보장할 수 있습니다.
0.12.16,In this case the problem is that because the network has its geographical extension. This node for instance could be in California  and this node could be in Japan  in Tokyo.,이 예제에서의 문제는 네트워크가 지역적으로 멀리 떨어져 있다는 것입니다. 이 노드는 캘리포니아  저 노드는 일본 도쿄에 있다고 가정해봅시다.
0.12.30,then there is a modification of the current database that is going to happen here  where as the simultaneous modification of the database is going to happen in this other point  and information will have to propagate through the network until the problem is identified  and after that the problem is some decision is taken ,이쪽 노드에서 데이터베이스 상태 변경이 생김과 동시에  다른쪽 노드에서도 상태 변경이 일어났습니다. 이 경우엔 변경에 대한 정보가 네트워크를 타고 전파되어야 하고  문제점(경합)이 어딘지 규명되어야 합니다.
0.12.52, And after  everyone is informed that it was decided to take one and reject the other one or the opposite.,경합점이 규명 된 후에는 네트워크상에서 어떤 변경을 취하고 나머지를 버릴것인지에 대한 결정이 내려지게 되고  이 결과를 네트워크 전체에 전파합니다.
0.12.57,so the problem here is that because of this network  then the case in which I have two concurrent accesses to on cell is much more difficult to solve than in a central database.,블록체인에서 이러한 경합 접근 문제는 중앙형 데이터베이스에 비해 해결하기가 훨씬 까다롭습니다.
0.13.10,That is  in blockchain  the problem is typically called double spending. Because if these are Financial transactions this is basically one person that is using his bank account to pay one vendor ,블록체인에서는 이런 문제를 double spending (이중 지출)이라고 부릅니다. 이예제가 금융  거래였다고 생각해봅시다. 구매자는 자신의 은행 계좌에서 업체의 계좌로 송금을 할 것이고
0.13.29, and this is the same bank account that is used to being used to pay another vendor  and the idea is that if there is not enough money in the system to pay both vendors at the same time ,동시에 이쪽의 같은 계좌에서 다른 업체로 송금을 하려고 합니다. 하지만 두 업체 모두에게 송금을 하기엔 계좌에 충분한 돈이 존재하지 않으므로
0.13.40,Then one of the two transactions need to fail., 둘 중 하나의 송금은 실패해야만 합니다.
0.13.42,otherwise you will have double spent  you have spent it twice the amount of money that you had in your bank account.,만약 실패하지 않는다면  계좌에 있던 돈의 두배를 지출한 꼴이 되겠죠. 그렇죠?
0.13.48,so once this call is made  and the application that wants to  that is connected to this node  says that it wants to write on the cell X  the value of this function f computed on value 4.,다시 말해  앱으로부터 Cell X에 f(4)와 f(3)의 계산값을 쓰고자 하는 요청이 발생하면
0.14.01,then at some point in time in the network there is the distributed layer that (distributed computation layer)  that has to compute the value of f of 4 and f of 3.,언젠가는 분산 컴퓨팅 레이어에서 이 계산들을 수행하게 됩니다.
0.14.11,Once these things are computed then at some point there needs to be a consensus algorithm  so the distributed database layer that is going to decide which one is going to be really written in the database if it's going to be x=3 or x=4.,이 두 값들이 계산 된 후에는 “합의 알고리즘”이 필요합니다. 분산 데이터베이스 레이어는 합의 알고리즘을 통해 두 계산 값 (f(3) or f(4))중 어떤 값을 Cell X에 반영할 지 결정하게 됩니다.
0.14.24,and after that the other layers are the virtual machine  which is the piece of code that is in charge of performing all those computations  in particular performing the computations of f.,다음 레이어로 가상머신 레이어가 있습니다. 가상머신 레이어는 계산을 수행하는  특히 이 경우엔 f의 계산을 수행하는 레이어입니다.
0.14.38,And after that you have on top of that  the languages  in which you are going to express the business logic of f  (inaudible) to virtual machine.,더 위에는 언어 레이어가 있습니다. 언어 레이어에서 함수 f의 로직을 정의합니다.
0.14.45,So all these layers of the different layers of the system seen from the system developer side,시스템 코어 개발자의 시선에서 바라본 각 레이어의 설명이었습니다.
0.14.53,Now the P2P layer is difficult to get right because also is one of the layers that is the most attacked in the system.,P2P레이어는 제대로 만들기가 상당히 까다로운 레이어입니다. 주로 공격의 타겟이 되는 레이어이기도 합니다.
0.15.05,so it receives many attacks of the attempts of impersonation  message deletion  of fake messages  and denial denial Services  Spams or something like that.,사칭이나 메시지 삭제 혹은 위변조  DDoS공격 및 스팸 등 갖가지 공격을 받는 레이어인데요
0.15.18, So it's very easy for attackers to just a add their own node to the system and start sending invalid transactions or invalid states onto other nodes,시스템에 악의적인 노드를 추가해서 체인 자체를 공격하는것이 그다지 어렵지 않기 때문에  이런 공격들로부터 시스템을 보호하는것은 굉장히 중요한 부분입니다.
0.15.30,That's protecting against this type of attacks is very important.  it's also very important that the p2p layer is properly optimized  because it is going to have a large resource requirements. a lot of messages are going to be sent through the p2p layer  and also those type of codes are known for being difficult to get right.,또한 P2P레이어는 많은 양의 메시지가 전달되는 레이어로  자원 요구사항이 높으므로 최적화가 매우 잘 되어있어야 합니다. 이러한 3가지 유형을 잘 만드는것은 일반적으로 매우 어렵다고 여겨지는 부분들입니다.
0.15.53,In Tezos we had a bug due to a mistake. Mistake was a string that looked as if it was empty but contained a \0 inside. Those are the typical bugs that attackers are going to identify and going to try to exploit in order to take your system down,테조스도 실수로 인한 버그가 있었습니다. 이 버그는 잘못된 문자열로 인해 발생한 버그였는데  눈으로 보기에는 비어있는 스트링이었지만 사실은 문자열 종료 지시자가 들어있었습니다.
0.16.12, and potentially try to disturb the computation of the system or steal some kind of value out of it.,해커들은 주로 이런 유형의 문제점들을 악용해서 시스템을 다운시키거나  시스템의 계산을 방해함으로써 부당한 이득을 취하려고 합니다.
0.16.23,So the challenge in the p2p layer is to be able to generate all that code in an optimized way  and from a specification in such a way that the code is directly correct.,다시 말해서 P2P 레이어가 어려운 이유는 그 많은 코드들을 극한으로 최적화 하고  사양 및 설계검토를 통해 코드를 “완전하게” 만들어야 하기 때문입니다.
0.16.35,that’s what we would ideally want to do. so optimize code that consumes as little of bandwidth as possible or resources possible  directly from specification in such a way that we can change the specification whenever we need ,즉 이상적인 코드는 최적화가 잘 되어서 자원을 효율적으로 사용하고  만약 사양 변경이 필요할 때에는 잘 짜여진 설계사양을 바탕으로 변경분에 대한 코드를 자동으로 만들어내고
0.16.52,And it generates the rest of the code and prove it correct because we don’t want to have these types of errors in the system.,만들어진 코드의 무결성까지 검사하는 코드라고 할 수 있겠습니다.
0.17.00,Now the distributed computation layers. so the idea here is that in this distributed database  instead of having the applications outside of the database perform the computations  the applications are going to connect to a node  and are going to tell the node what computations they want done.,분산 컴퓨팅 레이어에 대한 내용입니다. 요지는  분산 데이터베이스 (체인) 외부에 있는 앱에서 계산을 수행하기 보다는  앱들이 노드에 연결되고 요청을 통해 어떤 계산이 이루어져야 하는지 요청을 하는 것입니다.
0.17.20, and according to the motto after that  this computation is going to be performed in a subset of nodes of the network  and after that the result is going to be broadcasted to all the other nodes.,이 계산들은 네트워크에 속한 다른 하위 노드들에 의해 수행이 되고  계산의 결과는 다른 노드들에게 전파됩니다.
0.17.31,The idea of having the computation done by a subset of the nodes instead of having it done by an external application that cost from the outside is to increase the reliability of the system.,이렇듯 체인 밖의 앱에서 계산을 하지 않고 체인 내의 노드에서 계산을 수행하는 이유는 시스템의 안정성을 높이기 위해서입니다.
0.17.52,if a random subset of nodes is selected to do the computation then it's very unlikely that random subset is going to be the subset of nodes that is owned by an attacker  and therefore it's going to be harder to tamper with that computation.,만약 계산을 담당 할 노드가 무작위로 선정된다면  선정 된 노드가 악의적인 목적을 가진 노드일 확률이 매우 낮아지고  이는 곧 시스템의 계산 결과에 대한 악영향을 줄일 수 있겠죠.
0.18.08, so there are different models. The most robust model is that every single node in the network is going to do a copy to do a computation of the function that needs to be computed.,이 측면에서도 여러가지 모델이 있습니다. 가장 안전한 모델은 체인 상의 모든 노드가 같은 계산을 수행하는겁니다.
0.18.22, That's very resource intensive  so most of the time a random subset of node is selected every time that a computation is to be done.,이 방법은 굉장히 자원 효율이 낮기 때문에  일반적으로 무작위의 노드들을 선정해서 계산을 수행하게 됩니다.
0.18.33,With the idea that the attacker not being able to predict this Randomness  it's going to be very unlikely that you own all this subset of nodes that are selected for the computation  ok so it's a probabilistic defense against potential attackers,노드 선정 과정은 무작위이기 때문에  해커가 미리 자신의 노드가 선정될 지 알 수 없습니다. 즉 혹시 모를 악의적인 공격을 확률적으로 차단한 겁니다.
0.18.53,(and after  well ) you could have the only computation that is on the entry point. Most of the time entry point is owned by the attacker so basically that would mean just having a pure database in which the computations are done outside and not inside of the system,물론 진입점에서 계산을 수행할 수도 있습니다. 사실 많은 경우에 진입점은 해커가 점유하고 있지만 이 지점은 독자적인 순수한 데이터베이스를 가지고 있고  그렇기 때문에 계산이 체인 밖에서 이루어지는 것과 같은 효과를 가집니다.
0.19.08,Most blockchains use this model. Subset of Random nodes are generated and that's what the computation of all the contracts the functions happens and it's also the case for Tezos.,대부분의 블록체인은 이 모델 (무작위 선정)을 사용합니다. 무작위로 선정 된 노드에서 모든 컨트랙트와 계산이 수행되고  테조스도 같은 방식을 따릅니다.
0.19.24, the challenges of the distributed computation layer are to understand the consequences of each algorithm. The subset of nodes that are chosen randomly can be larger  can be smaller  can be of different properties ,분산 컴퓨팅 레이어의 어려운점은 각 알고리즘으로 인한 영향을 이해야한다는 점입니다. 무작위로 선정된 노드들은 크거나 작을 수 있고  성격이 다를 수 있습니다.
0.19.33,and all those choices are going to impact the global properties of the network like the lightness the latency and all those kind of things.,이러한 점들은 전체 네트워크의 쾌적함 혹은 지연등에 영향을 미칠 수 있습니다.
0.19.49,So all those parameters need to be carefully tuned in such a way that globally the network performs in the best way while keeping the highest possible level of security.,전체 네트워크 성능을 고려하면서도 높은 보안 수준을 갖추기 위해선 이런 인자들은 매우 세심하게 조절해야 합니다.
0.20.0,The other problem is that all these algorithms are pretty new  and we don't know what are the properties. and we would like to have more proofs  more formal proofs   about how they impact the global system.,다른 문제점은 이 알고리즘들이 나온지 얼마 되지 않아서 특성이 잘 알려지지 않았따는 점입니다. 이 알고리즘들이 시스템에 어떤 영향을 미치는지에 대한 확실한 증명이 더 있으면 좋겠죠.
0.20.20,the first challenge is that these algorithms are already sitting on a different layers that are below  in particular the p2p layer  and in order to experiment with the computation layer and change things very easily it would be much easier if the p2p layer that was below was are generated from a specification ,이런 알고리즘들이 이미 레이어 하부에 깊숙이  특히 P2P레이어에 자리잡고 있기 때문에 생기는 어려운점이 있습니다. 컴퓨팅 레이어에 변경이나 실험을 하고싶을 때  만약 P2P 레이어가 설계사양으로부터 자동으로 만들어진 코드였다면  매번 변경사항을 P2P레이어에 직접 반영하지 않아도 됐을 것입니다.
0.20.41,in such a way that every time we change the algorithm in the distributed computation layer  then we can generate the rest of the p2p layer  we don't need to manually rewrite the p2p layer. So would be very useful to have a code generation from the high-levels to the lower levels.,즉 상위 레이어에서 하위 레이어까지의 코드가 자동으로 변경사항에 맞게 변화할 수 있으면 편하겠죠.
0.21.02,okay that was for the distributed computation layer. the next layer is the distributed database layer.`,다음 레이어는 분산 데이터베이스 레이어입니다.
0.21.11,so what happens here is that in the system  there are two potential states at the same time. so here in this example  there is part of the network that thinks that the current state is the red State  s3  and part of the network that thinks that the current state of the database state is s4.,시스템에는 동시에 2개의 상태가 존재할 수 있습니다. 이 예제에서 보시다시피 네트워크의 일부는 현재 상태를 빨간색(s3)으로 알고 있고  나머지는 파란색(s4)로 알고 있다고 해봅시다.
0.21.37, These states are going to propagate  and at some point in time there's one piece of the network  one part of the network  that is going to  note this  that there are two candidates for being the main state of the database  and this Frontier  between the blue and red will have to decide which state to adopt and then that will move the frontier,이러한 상태는 네트워크를 통해 전파 되다가  언젠가는 시스템의 어느 부분은 두가지의 상태가 공존한다는 것을 알게 될것입니다. 그 시점에 이 프론티어 노드는 현재 상태가 파란색인지 아니면 빨간색인지 결정을 내리고
0.22.02,until the system becomes all blue or all red. So basically what happens here we have a typical algorithm is that this node here decides for instance has to be blue becomes blue  informs the other nodes that now these 2 nodes are blue  and these two now have to decide to decide to move to be blue as well and then the whole network is blue. that's how consensus algorithm typically works,시스템 전체의 상태가 하나로 귀결될 때 까지 이 과정은 반복됩니다. 다시 말하면 이 노드 (프론티어 노드)가 현재 상태를 “파란색”으로 결정했다면  인접한 다른 노드들에게 “파란색”의 상태를 전파하고  그 다음엔 이 노드들 역시 “파란색”으로 결정된다면  전체 시스템의 상태는 “파란색”이 될 것입니다. 이것이 합의 알고리즘의 작동 방식입니다.
0.22.27,they're bad news about consensus algorithms. The first bad news is that impossibility theorem from 1985 that says that you cannot have a consensus algorithm that at the same time terminates in which everyone agrees on the same value and the value makes sense,하지만 합의 알고리즘도 한계가 있습니다. 불가능성 정리(1985)에 의해 알고리즘이 종료됨과 동시에 모든 노드가 같은 값을 가지며  그 값이 말이 되는 경우는 없다는 것이 설명되었습니다.
0.22.47,. so because of this impossibility theorem  we already know that the consensus algorithm will have to abandon one of these properties  and the only property that is reasonable to abandon is a termination.,불가능성 정리에 따르면 합의 알고리즘의 이러한 특성 중 하나는 버려야 합니다. 버려도 될만한 유일한 특성은 “종료”입니다.
0.23.00,so that means that actually all these consensus algorithms are actually semi-algorithms  and they may not terminate. They may terminate in some cases but they're going to be cases in which they do not terminate.,달리 말하면 실제 사용되고 있는 합의 알고리즘은 전부 반쪽짜리라는 이야기이고  그 알고리즘들은 종료(완료)되지 않을 수 있습니다. 종종 종료 할 수도 있지만 안 될 수도 있다는 말입니다.
0.23.11,and because they do not terminate  then we have at the same time in the network multiple current states of the database. So within a network this database has multiple concurrent multiple current states that are potential candidates for being the state of the database ,알고리즘이 종료하지 않기 때문에 네트워크 내에 여러가지의 상태가 공존할 수 있습니다.
0.23.31, and the nodes that have decided that they're using this state or another state  the state of the node is going to change with time.,노드들은 한가지 상태 혹은 다른 상태로 천이를 결정할 수 있습니다. 즉 노드의 상태는 시간에 따라 변합니다.
0.23.41,So in this example here  is the same examples before  we see that these nodes 1  5 and 4 are considered that the current state of the database is the blue State ,이 예제에서는 노드 1  5  4는 데이터베이스의 현재 상태가 파란색이라고 생각합니다.
0.23.54,while States a node 2 and 3 consider that the current state of the database is the red State.,하지만 노드 2  3은 데이터베이스의 현재 상태가 빨간색이라고 생각하고 있죠.
0.24.00,at some point in time the nodes that are on the frontier  they will learn that there is also a blue State on top of the red State  and they're going to decide to swap or not. So in this example  node number 2 decided to swap to Blue and after that node number 3 decided to swap to blue as well  and then the whole system became blue.,언젠가는 프론티어 노드가 데이터베이스 내에 존재하는 빨간색과 파란색 상태에 대해 알게 될것이고  자신의 상태를 바꿀지 아닐지를 결정하게 됩니다. 즉 이 예제에서  노드 2가 파란색으로 천이한 뒤 노드 3도 따라서 파란색으로 천이하면  시스템 전체는 “파란색” 상태를 갖게 됩니다.
0.24.23,there is another way of showing this. this is the representation most of the time is used. this represents are of representation branches. so up to this point the system had only one current state  and at this point in time part of the nodes moved or decided to follow the blue state that are part of nodes that decided to follow the red State  and this branch had 2 nodes at the beginning ,이걸 표현하는 다른 방법도 있습니다. 많은 경우에 이 방법으로 묘사되곤 합니다. 이 그림은 상태의 브랜치를 설명합니다. 최초에는 데이터베이스에 한가지 상태만 존재했지만  어떤 시점에 일부 노드는 파란색 상태를 따르기로 하고  몇몇 노드는 빨간색 상태를 따르기로 합니다.
0.24.48,and after that one node swapped  and then with only one node  one node swapped and it disappeared.,빨간 상태의 브랜치는 최초에는 2개의 노드를 가졌지만  하나의 노드(노드2)가 파란색으로 상태를 바꿨고  그 다음에 한개의 빨간 노드가 남아있었지만 이 노드도 파란색으로 상태를 바꾸면서 빨간 브랜치는 사라졌습니다.
0.24.55, okay so this diagram shows how in the system there are states that there's convergence on a single state and after multiple states appear and the Dynamics of how some nodes move to the other Branch until one of the branches disappear. we have consistency again convergence in the blue State and after they're going to be new states appear et cetera.,이 그림은 시스템에 여러가지 상태가 하나의 상태로 수렴할 수 있는지 보여줍니다. 노드들이 상태를 바꾸면서 생기는 역학이 브랜치가 없어질 때 까지 끼치는 영향에 대해서 말이죠. 지금은 파란색으로 시스템 전체가 수렴했지만 새로운 상태가 또 생기기도 하겠죠.
0.25.25,So this diagram here is the result of algorithms not terminating. okay this is the result of the theorem the impossibility theorem that says that consensus our algorithms may not terminate  and  at any point in time there may be multiple current states in the database,이 그림은 종료하지 않는 알고리즘에 의한 결과입니다. 합의 알고리즘은 종료하지 않을 수 있고  그렇기 때문에 특정 시점에 데이터베이스에는 여러가지의 상태가 공존할 수 있다라는 겁니다.
0.25.45,now that we understand how there are these multiple states in the database at any point in time  we want to add another property which is Fault tolerance. We would like this database to be fault tolerant  and they're typically 2 types of tolerances that are interesting ,여러가지 상태가 공존할 수 있다는걸 알았으니 다른 특성을 추가해봅시다. 장애 허용입니다. 장애허용성엔 일반적으로 2가지 흥미로운 방식이 거론되곤 하는데
0.26.08,which is Crash tolerance  tolerance to the fact that some nodes are going to crash and Hack tolerance  the rest of the fact that some nodes are going to be hacked by a malicious actors  and these actors will try to perturb  Disturb the system by sending Fake Messages  trying to impersonate people et cetera,첫번째는 노드의 충돌로 인한 장애를 설명하는 Crash Tolerance가 있고  두번째로는 비정상 메시지를 보내는 등의 악의적인 공격으로부터의 장애 허용성인 Hack Tolerance가 있습니다.
0.26.30,so the hack tolerance is called Byzantine failures.and the main idea here is that in order to be a fault tolerant  all the algorithms what they end up doing is that they end up doing a vote among the nodes ,Hack Tolerance는 비잔틴 실패라고도 합니다. 내장애성을 갖추기 위해서 노드들 사이에서 투표를 진행한 뒤
0.26.51, and deciding via some form of a majority rule which is the current state.,다수결에 의해 현재 상태를 정하는 방식입니다.
0.26.58, so basically if we go to the previous example here okay all the algorithms that are full tolerant will have to use some kind of majority rule to say “oh there are more Blues than reds so we're going to try to move to the blue side “ that’s the way all these algorithms and achieving fault tolerance,아까의 예제로 돌아가보겠습니다. 내장애성을 갖추기 위해서 노드들은 다수결 논리를 따라 “아 파란색 상태가 빨간색 상태보다 더 많구나” “그러니 파란색 상태로 움직이자” 따위의 결정을 합니다.
0.27.21, and informally that works because by hypothesis will only have a minority of nodes that are hacked. and if you have some kind of election mechanism or majority based decision process that because you only have a minority of nodes that have been hacked then you should be able to achieve a decision that is the one that would have been wanted by the nodes that are not being hacked,이렇게 동작하는 이유는 오로지 소수의 노드만이 해킹을 당했다고 가설을 세웠고  또한 다수결 투표 방식을 따르게 된다면 해킹당한 소수의 의견보단 해킹당하지 않은 다수의 의견으로 결정이 날 것이기 때문입니다.
0.27.50,That is the idea Behind having this majority rule based algorithms. most of the time when we say majority we don't mean 50% because of technical reasons the requirements tend to be around 1/3. you have a limit in most algorithms that says that you have at most 1/3 of nodes that can be malicious ,그것이 다수결 원칙을 기반으로 한 알고리즘을 사용하는 이유입니다. 일반적으로 “다수결”이라고 할때 50%로는 충분치 않습니다. 기술적으로 1/3 정도가 일반적인 요구사항입니다. 즉 다수결 원칙이 작동하려면 해킹당한 노드가 전체의 1/3이상이 될 수 없습니다.
0.28.16,and algorithm will still work. if you have more than 1/3 then there is no guarantee that the algorithm works.,만약 해킹당한 노드가 1/3 이상이 된다면 알고리즘이 작동한다고 보장할 수 없습니다.
0.28.22, but in that case all this algorithms work with some kind of voting mechanism and some kind of majority rule. This is very informal. And to formalize al that we will have to go into the details of the algorithms which would be a little bit too detailed for this presentation,어찌되었든 합의 알고리즘은 일종의 투표 메커니즘과 다수결 원칙을 기반으로 작동합니다. 위 설명은 굉장히 기본적인 수준입니다. 정확한 작동방식은 훨씬 더 복잡하지만 본 발표에 넣기엔 내용이 너무 많아 제했습니다.
0.28.39,In closed networks those things will work very well. so close algorithms  consensus algorithms in closed networks have been known for a while already.,폐쇄  네트워크에서는 이러한 것들이 잘 작동합니다. 닫힌 네트워크에서의 합의 알고리즘은 이미 잘 알려져있습니다.
0.28.53,the most popular is Paxos it was designed by Leslie Lamport in 90’s   and it has a lot of variants  for all type of cases that might appear.,제일 유명한 알고리즘은 90 년대 Leslie Lamport에 의해 설계된 Paxos입니다.  Paxos는 존재할 수 있는 많은 경우에 대한 유형이 있습니다.
0.29.04, it's proven correct  so it was formally proven correct with this tool among other tools but Leslie Lamport actually created this tool named TLA plus,Paxos는 정형적으로 검증되었습니다. Lamport는 TLA+를 직접 작성했는데
0.29.16, Which is a specification language and at the same time a model checker  in order to be able to prove the properties of concurrent algorithms,TLA+는 스펙 언어이면서 모델체커로 동시성이 있는 알고리즘을 검증할 때 사용합니다.
0.29.24,The reason why that's needed is because concurrent algorithms are notorious for being very complex and full of bugs.,이러한 툴이 필요한 이유로는  동시성이 있는 알고리즘들은 굉장히 복잡하고 버그가 많기로 유명하기 때문입니다.
0.29.34, so after having created paxos  Lamport thought that it would be good to have a system that allows to prove the property of the algorithm  and that's why he worked on TLA plus.,Paxos를 만들고 난 뒤 알고리즘의 특성들을 검증할 수 있는 시스템이 필요했기 때문에 TLA+를 작성한 것이죠.
0.29.48,These are typical variances of paxos algorithm. you have a Byzantine failures  you have sequences  multi paxoses for sequence of values  you have different compromises for number of rounds that you request to converge vs. pool quorum and things like that ,이것들은 Paxos 알고리즘의 일반적인 유형들입니다. 비잔틴 실패  순차적 값을 위한 다중 Paxos  시스템 상태가 수렴하기 위해 필요한 라운드 계산 vs pool quorum 등이 있습니다.
0.29.55,and he has simplified versions like the Raft  in any case there are a lot of variants of paxos  and paxos is by far the most used algorithm in the industry for closed. networks.,또 약간 심플한 버젼인 Raft도 있습니다. 대체적으로 Paxos의 유형은 많고... 폐쇄 네트워크 세계에서는 어쨌든 Paxos가 가장 잘 알려진 알고리즘입니다.
0.30.10,Closed networks are things like a Google  Amazon  a networks in which one operator owns all the nodes and the number of nodes is known. There a limited number of nodes,폐쇄네트워크란 구글  아마존같이 하나의 관리자가 모든 노드를 관리하고  유한한 노드의 갯수가 알려진 네트워크를 말합니다.
0.30.30,This still can get hacked  but they’re limited.,해킹은 당할 수 있지만 파급은 미미합니다.
0.30.35,In open networks  in open networks it was thought for a long time that consensus algorithms were impossible  due to what is called the sybil attack.,공개 네트워크에서의 합의 알고리즘은 sybli 공격때문에 불가능하다고 여겨졌습니다.
0.30.48,the sybil attack is the fact that we just said before that the way these algorithms work is by voting in by a majority rule. when you're in a closed Network  the votes there are certain number of nodes that can be attacked at most 1/3 ,앞서 설명했다 시피 합의 알고리즘은 투표와 다수결 원칙에 의거해 작동합니다. 폐쇄 네트워크에서는 공격당할 수 있는 노드의 수가 최대 1/3으로 정해져있습니다.
0.31.06,okay but at the end of the vote is going to solve that problem and just going to be a majority of non hacked nodes that are going to finally decide.,하지만 투표 결과 다수결에 의해서 해킹당하지 않은 나머지 2/3 의 노드의 결정을 따르겠죠.
0.31.16,the problem with open networks is that the attacker can create as many node it as he wants  and the result is that he can very easily then change the result of a vote because he can create millions and millions of nodes and have them all vote in the sense that he wants,공개 네트워크에서는 악의적인 노드가 얼마든지 생겨날 수 있습니다. 수 백  수 천의 노드를 생성해서 공격자는 쉽게 투표의 결과에 영향을 미칠 수 있습니다.
0.31.36,so the problem with open networks is that the way closed networks work is incompatible with the openness of the network. (?) is difficult to have a vote and a majority rule in an open network when attacker can create as many nodes as it wants. So that's the sybil attack.,즉 문제는 폐쇄형 네트워크의 작동 방식이 공개 네트워크와 호환되지 않는다는 점입니다. 공격자가 많은 노드를 만들어 투표와 다수결 결과를 뒤집으려 할 수 있습니다. 이것이 sybil 공격입니다.
0.31.52,Because of this  it was thought that consensus in open networks was impossible until Nakamoto in 2008 introduced Bitcoin. The idea of Nakamoto is to solve the problem in a completely different way is to use economic incentives to solve the problem,그렇기 때문에 공개 네트워크에서의 합의 알고리즘은 불가능하다고 여겨져 왔습니다. 적어도 2008년에 Nakamoto가 Bitcoin을 발표하기 전까진 말이죠. Nakamoto의 방법은 완전 다른 종류로  경제적인 인센티브를 발생시킴으로써 문제를 해결했습니다.
0.32.15, so the way he does that is that he says  in this network what we're going to do is that we're going to force people to pay to participate and we're going to reward them for reaching consensus,Nakamoto의 합의 알고리즘은 사람들을 네트워크에 참여시키기 위해서 비용을 만들고  합의에 도달할 때 보상을 주는 것입니다.
0.32.29,. so for people that participate and reach consensus this should be cost-neutral  because they pay and they get paid after that. for people that participate but are not interested in reaching consensus than it would create important costs for them.,시스템에 참여하면서 합의에 도달한 사람들은 본전입니다 (돈을 내고  다시 받아왔으니까요). 하지만 참여만 하고 합의에 도달하지 못한 사람은 손해입니다.
0.32.47, so that's where this decentivizes not reaching consensus and if you're an attacker and you want to create millions of nodes then immediately you have to pay millions of time.,즉 이를 통해 공격자로부터 “의도적으로 합의에 이르지 않는 행위”를 할 이유를 없애버리는 겁니다. 왜냐면 노드를 만드는 순간 부터 많은 돈을 지불해야 하기 때문이죠.
0.33.30,So the idea here is not that is going to prevent the system from being attacked. It is that it's going to make the attack so expensive that it doesn't make sense given the amount of money that there is to steal in the system.,다시 말해 공격을 막는다기 보단  공격에 대한 비용을 굉장히 비싸게 만듬으로써 시스템에 대한 공격이 무의미하게끔 만드는 것입니다.
0.33.14, so that's the idea of Nakamoto. And this idea  he transformed into an algorithm. His original algorithm is proof of work. In proof of work basically the clue is to solve a puzzle cryptographic puzzle. it's reversing a hash function.,이것이 Nakamoto의 아이디어고  이것을 알고리즘으로 만들었습니다. Nakamoto의 원래 알고리즘은 proof of work입니다. PoW는 기본적으로 hash function을 역으로 계산하는 암호 퍼즐입니다.
0.33.33,And  in order to participate  you need to own  a very powerful hardware to solve this cryptographic puzzle,그리고  합의에 참여하여 암호퍼즐을 풀기 위해서는 고사양의 하드웨어가 필요합니다.
0.33.43,the subset of random nodes that is chosen to do the computation. so the way these random nodes are chosen to do the computation is that the first one that sold the cryptographic puzzle is basically the node that is going to do the computation.,문제를 풀기 위해 선정 된 무작위 노드들 중 제일 먼저 암호퍼즐을 푼 노드가 계산을 수행할 노드가 됩니다.
0.34.00,so that introduces here  a randomness that cannot be predicted,이 특성 역시 미리 예측이 불가능한 무작위성을 만들어냅니다.
0.34.05, and that's how the pay to participate part of the algorithm works  and once the node  that is going to build the block is defined then it will create a block and it would add the fee for itself inside,이것이 알고리즘의 pay to participate 부분이 작동하는 방식입니다. 블록을 생성 할 노드가 선정 되면  그 블록 내에 자신의 보상을 추가합니다.
0.34.23,This is a very important part which is the fact that the fee is added into the block that was just created. That is what incentivizes the consensus.,이 부분이 중요한 부분인데요  방금 만들어진 블록에 보상을 추가하는것이 중요합니다. 왜냐면 그 보상이 합의 알고리즘에 참여해야 하는 실질적인 이유이기 때문이죠.
0.34.36,and we'll see it going back to previous image. it's this one. each one of the miners that created each one of these blocks added the reward for the work into the block,이전 이미지로 돌아가보면... 이 사진이요. 블록을 만든 각각의 채굴자들은 블록을 만듬과 동시에 자신의 보상을 블록 내에 남기게 되고
0.34.52,and because they added the reward for the work into the block when there is one branch that disappears all the rewards that these miners had added into the blocks disappear as well ,이 보상은 블록 내에 남겨져 있기 때문에 만약 방금 만들어진 블록을 포함한 브랜치가 사라지게 되면  채굴자들을 위한 모든 보상까지 다 사라지게 됩니다.
0.35.05, so if this branch  or these miners disappears  then all the money that they would have been paid back is gone  and because of that they have an incentive on working on the branch that is the most likely to remain.,이렇게 브랜치가 날아가서 보상을 받지 못하게 되면 받을 수 있었던 보상을 받지 못하는 꼴이 되므로  채굴자들은 결과적으로 가장 살아남을 가능성이 높은쪽으로 붙으려고 할 것입니다.
0.35.21,so we're saying that in order NOT to lose money  okay  the miners have an incentive into finding which branch is the most likely  and then immediately uses this branch instead of using any other one.,즉 돈을 “잃지 않기 위해서” 채굴자들은 어떤 브랜치가 가장 유력한 생존 후보인지를 찾아내고  그 브랜치를 합의 알고리즘을 통해 유지시키는 방향으로 장려됩니다.
0.35.37,if they mine  if they create blocks on a branch that is not the most likely they're taking the risk of not getting the money back.,살아남을 확률이 희박한 브랜치에 블록을 생성해서 이어붙여봤자 돈을 날리는 리스크만 잔뜩 짊어지는 셈이죠.
0.35.48,"and this is what holds the whole algorithm. it's that it doesn't matter who wrote the code that the miner is running. it doesn't matter who is the miner  it doesn't matter how they do this block generation et cetera.",이게 알고리즘의 핵심입니다. 채굴자가 채굴을 위해 사용하는 코드를 누가 작성했는지는 중요하지 않습니다. 채굴자가 누구인지도 중요하지 않습니다. 블록을 어떻게 생성하는지도요.
0.36.03, in all cases the miner has his interest in joining the majority Branch to consensus in such a way that he gets his money back,어떤 상황에서도 채굴자는 자신의 블록이 살아남을 확률이 높은 브랜치에 불록을 생성해서 보상을 받으려고 할 것이고
0.36.19,so this is the proof of work algorithm,이것이 Proof of Work입니다.
0.36.26, tezos doesn't use these algorithm. it uses an algorithm that consumes less energy  less electricity  which is proof of stake. One variant of proof of stake tezos uses is liquid proof of stake variant.,테조스는 Proof of Work알고리즘을 용하지 않습니다. Tezos는 에너지 및 전기가 적게 드는 PoS를 사용합니다. PoS중 Tezos가 사용하는 유형은 Liquid PoS인데요
0.36.40, in here we present a more generic algorithm. so in proof of stake the ideas are the same  the implementation is slightly different. pay to participate and be rewarded for reaching consensus  the main ideas of Nakamoto remains.,이 표가 PoS알고리즘을 간략하게 설명합니다. PoS도 기본은 같습니다만 구현이 살짝 다릅니다. Pay-to-participate  합의 도출 등의 아이디어는 Nakamoto의 PoW아이디어와 같습니다.
0.36.55,instead of buying hardware in Tezos you need to own tokens to participate. so that's the pay to participate part.,테조스에서는 하드웨어를 사는 대신에 토큰을 소지하여야 합니다; 이 부분이 pay-to-participate 인 것이고요.
0.37.04,The builders of the blocks are chosen randomly and once it's your turn to build a block you have to leave a bond as a ransom until the networks is convinced that you didn't do anything wrong  and after that this bond will be unfrozen in given back to you.,블록을 만드는 노드는 무작위로 선정됩니다. 만약 여러분의 노드가 이번에 블록을 생성하는 노드로 선정 되면  여러분은 소정의 토큰을 일종의 몸값으로 “묻어야” 합니다. 네트워크가 합의에 도달해서 여러분이 블록에 장난을 치지 않았음이 검증될 때 까지요.
0.37.22, okay so that's the way that you pay to participate because you need to own tokens  and in some sense there is some money that is kept aside for your participation to make sure that.  you can lose money if the you didn't participate properly.,이것이 합의 알고리즘에 참여하는 pay-to-participate 방식입니다. 일정량의 토큰을 보유하고 있어야 하고  또한 합의 알고리즘에 허투루 참여(e.g. 메시지 조작 등 악의적인 행동)을 하면 돈을 잃을 수 있습니다.
0.37.47,The reward for reaching consensus is every time you create a block is  you add a fee into the block exactly the same way as proof of work.,합의에 대한 보상은 PoW와 같이 블럭을 생성할 때 마다 보상을 블럭에 담는 식입니다.
0.37.58,and here after sometime then your bond will be unfrozen.,일정 시간이 지나면 여러분이 묻었던 “몸값”을 다시 돌려받게 됩니다.
0.38.04,to pay to participate: be rewarded for reaching consensus. there are couple of differences with respect to proof of work  because it is very easy to create new blocks. it's not resource consuming  then we have to be a little bit careful on the fact that people don't generate blocks in multiple branches.,다시 말해: 합의 알고리즘에 돈을 내고 참여하고  합의에 도달하면 보상을 받는 방식입니다. PoW 과 비교하면 몇 가지 다른점이 있습니다. PoS에서는 블록을 생성하는 것이 굉장히 쉽기 때문에  사람들이 다른 많은 브랜치에서 블록을 생성하지 않도록 조심해야 합니다.
0.38.29,the whole previous algorithm works because you have to choose the right branch. you have to choose the more likely branch. If we go back here.. In proof of work  you have to choose on which branch you are going through at your block,이 알고리즘들은 사람들이 올바른 브랜치를 선택하려 하기 때문에 작동합니다. 브랜치는 잘 골라야 합니다. 조금 돌아가 보면... PoW에서는 어느 브랜치에 블록을 추가할지  골라야 합니다.
0.38.45, you cannot do it in both (blocks) because it's too expensive. In proof of stake you also have to choose carefully in which branch you are going to add your blocks. you have to choose the most likely  and you cannot do it in both because otherwise you will lose the money that was there in the bond.,두 브랜치 모두에 추가할 순 없습니다. 비용이 너무 비싸니까요. PoS에서 역시 마찬가지로 신중히 골라야 합니다. 두 브랜치 모두에 블록을 추가할 순 없습니다. 왜냐하면 둘 중 사라지는 브랜치에 묻어둔 “몸값”이 날아가니까요. 이것 때문에 double baking과 bonding mechanism이 존재하는 것입니다.
0.39.03,that's why there is this double baking and this bonding mechanism here. In any case  besides from those small details and the fact that it consumes less electricity  this algorithms are the implementations of the same main idea. the main idea is pay-to-participate  be rewarded for reaching consensus.,전기를 덜 먹는 등 PoS의 이런 세세한 디테일을 제외하면 전반적인 구성과 구현은 PoW와 같습니다. pay-to-particiate  be rewarded for reaching consensus!
0.39.25,"and that's the economic workaround against the sybil attack  the type of attack that prevents the more classical algorithms to be used in open networks.",이것이 블록체인과 같은 공개 네트워크에 합의 알고리즘을 적용하기 힘들게 하는 주범인 sybil 공격을 대응한 경제학적인 방법입니다.
0.39.40,Now the Nakamoto conjecture is the fact that no other algorithm has been found  til now. All the algorithms that do consensus in open networks they have this economic incentive behind  and they need to have a currency in order for them to work.,“Nakamoto 추측”은 다른 형태의 합의 알고리즘은 아직까지 발견되지 않았다 라는 추측입니다. 공개 네트워크에서의 합의 알고리즘은 어떤식으로던 “보상”을 필요로 하고  그렇기 때문에 자체적인 화폐를 보유해야 합니다.
0.40.03,so the idea is that we haven't found any algorithm that doesn't have an internal currency. Which also means that the reason why blockchains have their own currency is because it's required by the algorithm itself. it's a technical necessity.,달리 말해 코인이나 토큰을 통한 보상이 없는 합의 알고리즘은 아직까지 찾지 못했다는 것입니다. 모든 블록체인이 자체적인 코인이나 토큰을 가지고 있는 기술적인 이유가 여기에 있습니다.
0.40.26,That's a bad news. That's a very bad news because basically what we wanted was an open database with a consensus algorithm inside and we ended having a currency. And currencies bring a lot of trouble with them. They mean that now there's going to be money inside of the system  which means that you need to have financial system grade security.,흠 좋은 소식은 아닙니다. 왜냐면 블록체인을 통해 이루려던 것은 단순히 개방 된 합의 알고리즘을 가진 데이터베이스인데  화폐를 만들어야 했기 때문입니다. 화폐는 화폐 나름대로 또 다른 문제점들을 야기합니다. 시스템 내에 돈이 존재하다 보니  금융권 시스템 수준의 보안을 갖춰야 하겠죠.
0.40.50,It means that you also need to interoperate with other financial systems. That means basically that your database  instead of being a database just for simple applications and Google docs and things like that ,또한 다른 금융 시스템과도 엮여야 할 필요도 생깁니다. 다시 말해서 이 데이터베이스는 더이상 구글독스같은 간단한 앱을 위한 데이터베이스가 아니라
0.41.03,Immediately moves to the next level in complexity  which is  now it's a financial database with all the financial requirements.,복잡성 측면에서 한단계 나아간  금융권의 요구사항을 만족시켜야 하는 “금융 데이터베이스”이 되어버린 것이죠.
0.41.13,Distributed database's challenges. The first challenge is to better understand distributed consensus algorithms. It's probably the first time that we have algorithms that use economic incentives in order to work.,분산 데이터베이스가 가진 어려운 점입니다. 첫번째로 분산 합의 알고리즘을 잘 이해해야 함에 있습니다. 인류는 블록체인을 통해 “작동하기 위해서는 보상이 필요한 합의 알고리즘”을 처음으로 적용해본 것일수도 있습니다.
0.41.30,We already knew for a while that economy and algorithms were related  but it's really the first time that we have the only algorithm that we know in order to solve this problem  it is completely economic based.,경제와 알고리즘이 연관되어있다는 사실은 꽤 오랜기간 알고 있었지만  합의 알고리즘처럼 경제적인 보상 외엔 답이 없는 경우는 이번이 처음입니다.
0.41.47,So this is a completely new type of algorithms  and because of that we need to better understand them. We need to stimulate them  we need to attack them we need to design better algorithms.,아무튼 이렇듯 완전히 새로운 알고리즘이기 때문에 이해도를 높여야 할 필요가 있습니다. 많은 연구와 실험을 통해 더 나은 알고리즘을 설계해야 할 것입니다.
0.42.00,The second thing that is important is that we would like to have better proofs around the properties of these algorithms. The first thing we would like to have is a prove or disprove Nakamoto conjecture.,두번째로는 알고리즘의 특성들에 대한 좀 더 완전한 증명이 있었으면 좋겠다라는 것입니다. Nakamoto 추측이 맞는지 아닌지  즉
0.42.12,"Know if ""Yes this is the only way of solving this consensus algorithm in open networks""  or ""No there is an algorithm that does not use a coin""",“오 맞아 이런식의 합의 알고리즘이 유일한 방법이야” 혹은 “아냐 코인 없이도 개방 네트워크에서 합의 알고리즘은 가능해” 라는 결론을 내는 것 말이죠.
0.42.23,And that will be very useful to have elements of answer in one or the other way  other than the fact that now we have never found any other algorithms,이런것들을 대답할 수 있는 지식이 조금 더 있으면 좋을 것입니다. 아직 다른 알고리즘을 전혀 찾지 못했다는 것만 제외하면요.
0.42.35,We would also like to have more proofs of the properties of this consensus algorithm. So by itself that would be very useful.,여하튼 합의 알고리즘의 특성에 대한 더 많은 증명이 있으면 좋겠습니다. 그것만 있어도 꽤 쓸모 있을겁니다.
0.42.44,The last thing is  again  all these algorithms  because there is a tower of layers  different layers  that depend on one or the other  every time you modify this algorithm then you have to propagate the modification all the layers that are below ,마지막으로  이런 알고리즘은 많은 유기적으로 묶여있는 레이어들로 이루어져 있기 때문에  알고리즘에 수정을 할 때 마다 하부 레이어로 변경사항을 전달해야 합니다.
0.42.59,"and it would be very useful to be able to generate the code automatically from a specificatio n in such a way that when we modify this layer  then immediately the order layers that are below can be generated automatically from a modified specification without having to rewrite all the code.",이런 변경이 가해질 때 마다 코드가 설계사양으로 부터 자동으로 생성된다면  손으로 코드를 다시 짤 필요 없이 알아서 변경사항이 잘 적용 될 것입니다.
0.43.16,Next layer: virtual machines. So the virtua machines today are the main attack vector of blockchains. Blockchains as of today hasn't failed because of their algorithms that are inside  or because a malicious attackers have added nodes and have been able to distort the current state of the database.,다음 레이어입니다; 가상머신. 가상머신은 블록체인 해킹의 주된 헛점이라고 할 수 있습니다. 블록체인 자체가 아직 망가지지 않은 이유는 알고리즘의 이유도 있지만  많은 시스템의 상태를 악의적으로 변경하려는 공격은 데이터베이스에 추가된 코드 몇 줄에 의해서 방어 되었습니다.
0.43.46,Till now they have all failed because of the code that is added to the database. So what is called a smart contract  the code in the smart contracts have bugs  and that's what the hackers use in order to steal funds or to destroy information that is inside.,만약 스마트 컨트랙트 코드에 버그가 있다면  해커는 그 헛점을 이용해 코인을 훔쳐가거나 정보를 파괴하는등의 공격을 합니다.
0.44.04,So until now it's this layer that has created the most problems.,그런 의미에서 가상머신 레이어가 가장 많은 문제를 일으켰습니다.
0.44.10,"Probably one of the reasons is that the early blockchains didn't design a virtual machine with security in mind. They were more interested in portability  standardization  probably speed  and also simplicity of implementation.",그 이유중 한가지는 아마도 초기 블록체인을 위한 가상머신을 설계할 때 보안이 그렇게 중요한 요소가 아니었기 때문일 수도 있습니다. 표준화  이식성  성능  구현의 용이성들이 더 중요했을 수도 있겠죠.
0.44.31,So the different virtual machines are here  we have the evm with some of its technical characteristics  WebAseembly and Michelson.,그래서 - 몇몇가지 가상머신들입니다. EVM과 그것의 기술적인 특징들  WASM  Michelson등이 소개되어 있습니다.
0.44.43,What is a very obvious in this comparison is that a Michelson was designed in order to avoid all the problems that  in order to make the programming of non-buggy programs simpler. And that's that's the purpose of Michelson.,이 비교에서 한가지 명확한 것인 미켈슨은 프로그래밍을 bug-free 하고 더욱 심플하게 만들기 위해 만들어졌다는 것입니다.
0.45.07,For instance Michelson has a infinite precision ints  so the person that is programming on Michelson doesn't need to worry about overflows or things like that  because it's already given out of the box by Michelson. Same thing for the data structures  etc.,예를들어서 미켈슨은 infinite precision int 형을 가지고 있습니다. 때문에 미켈슨  개발자는 오버플로우등의 문제를 고려하지 않아도 됩니다. 자료구조 등도 비슷비슷합니다.
0.45.25,Michelson was designed to make the life of the programmer of smart contracts easier  and to help him write code that is not vulnerable to attacks.,미켈슨은 스마트 컨트랙트 개발자가 조금 더 쉽게 컨트랙트를 만들 수 도록 돕고자 만들어졌습니다. 또한 외부 공격에 취햑하지 않는 컨트랙트를 작성하게끔 돕습니다.
0.45.35,So here are examples attacks that have happened in Ethereum. This is from a website  ethereum wiki  an external website  and it has a list of major issues that have resulted in losses of funds.,이더리움이 받았던 공격들의 예제입니다. Ethereum wiki라는 외부 웹사이트이고요  이런 굵직한 돈이 증발 된 사건들의 리스트가 있습니다.
0.45.55,Now  these are the typical  the most common bugs in smart contracts. Things like overflows. Things like reentrant bugs  that was the DAO  the fact that when one function calls another function and then comes back  and then you have to be careful that attack us cannot introduce in the middle other functions just before the the calling function returns.,보시는 것들이 스마트 컨트랙트에 존재할 수 있는 일반적인 버그들입니다. 오버플로우 같은것 들 말이죠. Reentrant 버그 (함수가 다른 함수를 호출하고  서브루틴이 종료되어 돌아올 때  임의의 악의적인 코드가 중간에 수행되는 취약점)는 DAO사태의 원인이었구요.
0.46.16,and there are also a lot of a combination of poorly thought features. That's probably one of the most difficult bugs. It's the fact that this virtual machines were written without thinking about all the possible combinations  all the possible ways that could be used ,그리고 단순히 잘못만든 기능들이 원인일 수도 있습니다. 잘못만든 기능은 아마 손보기가 좀 힘든 버그일 것입니다. 가상머신을 설계할 때에 모든 상황에 대처할 수 있게끔 설계되지 않았고
0.46.33,and very often there are a couple of things that together don't work well. Individually they were good ideas and good features but together they create a very complicated systems that are very hard to get right  and,많은 경우에 기능을 연계하여 사용 할 경우 잘 동작하지 않는 경우도 많습니다. 하나 하나만 따져보면 좋은 기능이었지만 같이 사용 할 경우 고치기 힘든 문제를 발생시킬 수도 있습니다.
0.46.52,that are easy to hack and then the funds are lost in there.,이런 문제점들은 해킹에 대한 취약점을 만들고  사람들이 돈을 잃어요.
0.46.58,Tezos virtual machine was designed to make the programming of smart contracts as easy as possible. In the sense that it should be easy to write a program that doesn't have bugs. That's the idea.,테조스 가상머신은 스마트 컨트랙트 프로그래밍을 쉽게 만들기 위해 만들어졌습니다. 버그 없는 프로그램을 짜는것은 쉬워야 합니다.
0.47.15,We use formal verification techniques to approve the property of those programs and among other things  to proove that they don't have bugs.,테조스는 형식 검증을 통해 작성 된 컨트랙트들의 특성을 검증하고  버그가 있는지 확인합니다.
0.47.23,There are many challenges in virtual machines. The main challenge is that because blockchains are open databases than anyone can put a piece of code on the database ,가상머신은 많은 허들이 있습니다. 가장 큰 허들은 블록체인 자체가 개방형 데이터베이스이고 누구나 코드를 올릴 수 있기 때문인데요
0.47.38,which means that users of this pieces of code are using pieces of code written by 3rd party most of the time. They don't know they have no guarantee of what these pieces of code could do.,이 말은 서비스를 사용하는 많은 사용자들이 제3자가 작성한 코드를 실행시키는 경우가 대부분이라는 뜻입니다. 사용자들은 이 코드가 무엇을 할 수 있는지에 대한 확신이 없습니다.
0.47.52,So here the problem is to help the users understand the properties of this 3rd party pieces of code. Users are going to see one piece of code that is on the blockchain and we need to have him to understand this piece of code is safe before using it.,그래서 사용자들에게 이 제3자가 만든 코드가 무엇을 하는 코드인지 이해할 수 있도록 도움이 필요합니다. 안심하고 써도 된다고 알려줄 수 있어야 하는 것이죠.
0.48.08,So the way this thing is done  for the most of the time  it's using formal verification techniques. Things like a model checking  abstract interpretation   embedding into therorem provers like F*  or coq  etc.,이런것들을 테조스는 형식 검증을 통해 제공합니다. Model checking  abstract interpretation  F-Star와 같은 정리 증명계를 사용하는 것입니다.
0.48.22,Another way of doing that for simpler programs is to recognize patterns  to allow creation of search engines as well.,다른 조금 더 간단한 프로그램 같은 경우는 사용 패턴을 조사하고  그것들을 찾아볼 수 있는 검색 엔진을 만드는 것입니다.
0.48.34,"Okay so these are the challenges of the virtual machine. Next there are languages. So the languages is the part that is the most visible to the programmer  the programmers are able to write the contracts in this languages and after that these are compiled to the virtual machine.",그 다음엔 언어입니다. 언어는 프로그래머에게 가장 인접한 구성요소입니다. 프로그래머들은 이 언어를 사용해서 컨트랙트를 작성하고 가상머신에서 수행하게끔 컴파일 합니다.
0.48.54,Here what happens is that not everyone has the same understanding of what a blockchain should be  and a blockchain should do. A lot of blockchain organizations still think that a blockchain should be a platform for decentralized apps like Google Docs. Any type of apps.,“블록체인은 무엇이다”  “블록체인은 무엇을 해야 한다”와 같은 질문에 모두가 다 똑같은 답을 가지고 있는건 아닙니다. 많은 블록체인 회사들은 블록체인이 구글 독스와 같은 분산형 애플리케이션의 플랫폼이 되어야 한다고 합니다. 그게 무엇이던 간에요.
0.49.18,In Tezos most people that work in Tezos are a little bit more pragmatic because of the limitations of the blockchain. The limitations in terms of performance  security  and all those kind of things.,테조스를 만드는 개발자들은 그것보단 조금 현실적입니다. 블록체인의 한계 때문인데요. 성능  보안 뭐 그런것들의 한계말입니다.
0.49.33,Many people in Tezos think that we should do things more step by step  and first make sure that we're able to automate simple legal contracts that talk about transactions. Financial transactions.,테조스 개발자들은 조금 더 천천히 한 단계씩 나아가야 한다고 생각합니다. 첫번째로 비교적 간단한 송금 처리가 필요한 법적 계약 같은것을 자동화 할 수 있어야 한다고 생각하고요.
0.49.50,So instead of having an application like Google Docs  we should try to do much simpler applications  like automating simple transfers of money.,그래서 구글독스 같은 앱을 만들기 보다는 훨씬 간단한 앱을 만들어야 할 것입니다. 이를테면 자동 송금이라던지..
0.50.04,Having simple escrows. Having simple payment systems between software companies and freelancers  things like that. Once all this part is done properly  and we have a system that is not hacked  is secure enough  has been working for a while  then after that we can start looking at other applications and a little bit more generic  less about financial transactions.,에스크로 시스템이나  회사와 프리랜서 간 비용 지불을 위한 시스템등도 좋습니다. 이런것들이 제대로 만들어지고 돌아가는 상태에서  시스템이 안전하고  오랜 기간동안 문제 없이 작동하고 난 후에야 조금 더 포괄적인 앱들을 생각해볼 수 있겠습니다.
0.50.33,In any case  there are different views of what a contract should be  what type of applications should be run on the blockchain. And because of these different views  they're going to be different views of what is the proper language to implement its applications.,컨트랙트 자체도 “무엇이어야 한다”라는 질문에 많은 답이 있습니다. 어떤 애플리케이션이 블록체인에서 수행되어야 하는지에 대해서 말이죠. 이런 다른 견해로 인해 컨트랙트를 구성하는 언어는 어떤것이 적합한지에 대해서도 많은 견해차가 있습니다.
0.50.52,In Tezos  we consider that these applications should be simple legal contracts  written in domain specific languages  in such a way that we have a better control on the properties of these programs ,테조스는 스마트 컨트랙트는 DSL로 작성된 심플한 법적 계약등이 스마트 컨트랙트가 되어야 한다고 생각합니다.
0.51.03,and we can prove their properties  which gives us a system that is globally more  secure  and that the contracts themselves should be written by specialized developers.,컨트랙트들의 특성을 파악하고 검증함으로서 전반적으로 더욱 견고한 시스템을 만들 수 있고  이런 컨트랙트들 역시 전문가에 의해서 작성되어야 할 것입니다.
0.51.14,People in Tezos think that there should be the web developers that do all the JavaScript part  or whatever is your frontend technology  there should be more specialized developers that do the contracts  companies that know how to manage formal verification tools and those kind of things ,테조스 사람들은 JavaScript를 건드리는 웹개발자가 있고  컨트랙트를 짜는 다른 전문가가 있어야 한다고 생각합니다. 형식 검증이나 관련된 검증툴에 대한 이해를 가진 회사들 말이죠.
0.51.33,and let the very specialized people that do the core itself.,그리고 정말 정말 전문가에게 코어 개발을 맡기고요.
0.51.38,Other organizations think that the contracts  the applications that run on top of the blockchain  should be universal  should be generic  and they should be written in generic languages like JavaScript or Python  and that any developer should be able to write these applications  these contracts.,다른 블록체인의 경우 스마트 컨트랙트는 보편적이고  포괄적이고  그렇기 때문에 더 JavaScript나 Python같은 일반적인 언어로 작성되어야 한다고 생각합니다.
0.51.58,That's the difference of positioning between different organizations and because of that there is going to be different consequences on the way this languages are designed  the virtual machines are designed  etc.,언어와 가상머신이 어떻게 만들어졌냐에 따른 결과를 낳게 됨에 있어서 블록체인 개발사간 입장 차이는 발생할 수 밖에 없습니다.
0.52.13,In Tezos we advise that everything that can be computed off-chain should be computed off-chain. So that's because blockchains are per essence slow.,테조스는 체인 밖에서 계산될 수 있는것들은 모두 체인 밖에서 계산되도록 권고합니다. 왜냐면 블록체인은 느리거든요.
0.52.28,We can always improve the speed of blockchain  but they're never going to be as fast as a computer executing operation sequentially in a single machine. so because blockchains are by essence slow  we need to be careful on the way with program on blockchains.,블록체인의 속도 자체는 개선의 여지가 있으나  아무리 개선을 해도 컴퓨터가 직접 계산을 수행하는 것 만큼 빨라질 순 없습니다. 블록체인은 느리기 때문에 체인 상에서 무엇을 수행해야 하는지에 대해 조금 조심스럽게 접근해야 합니다.
0.52.47,Here is a typical example of something that is very simple  but there's a right way of doing it  and a wrong way of doing it. So this is an application and this application - the only thing it does is that calls the contract with the value 9 ,여기 아주 간단한 예제가 있습니다. 같은 일을 하는 올바른 방법이 있고  잘못된 방법이 있습니다. 이 앱은 단순히 스마트 컨트랙트를 인자 9로 호출하는것 외엔 하는게 없습니다.
0.53.03,and the contract  the only thing it does is that it computes the square root of 9  which is three. So basically this calls f(9) and this thing returns  the f returns 3.,컨트랙트 자체도 유일하게 하는 것이라곤 9의 제곱근을 구하는 것 뿐입니다. 결과적으로 f(9)의 스마트 컨트랙트 호출을 하면  함수는 3을 반환하겠죠.
0.53.15,Now this very simple program is the wrong way of doing things. It's the wrong way of doing things because here you're asking the blockchain to compute a complex operation which is a square root.,이 방법은 잘못 된 방법입니다. 왜냐하면 블록체인에게 “복잡한” 계산인 제곱근 계산을 요청했기 때문입니다.
0.53.42,Blockchains are very slow. and because of that Tezos recommends that everything that can be computed outside of the blockchain should be computed outside of blockchain.,블록체인은 굉장히 느립니다. 그렇기 때문에 테조스에서는 체인 밖에서 계산될 수 있는 것들은 체인 밖에서 계산하도록 권고하고 있습니다.
0.53.53,Here is a very simple example of the right way to do things  and wrong way to do things. So in this example we have an application that calls a contract and this contract computes a square root of a number.,여기 아주 간단한 예제가 있습니다. 같은 일을 하는 올바른 방법이 있고  잘못된 방법이 있습니다. 이 앱은 스마트 컨트랙트 요청을 날리고  스마트 컨트랙트는 인자의 제곱근을 구합니다.
0.54.09,The application calls f  the f is the contract  with the value 9 and the contract just computed the square root. Now this very simple program is actually the wrong way of doing things.,앱이 컨트랙트 함수 f를 인자 9로 호출하면서  스마트 컨트랙트에서 제곱근을 계산했습니다. 하지만 이것은 잘못된 방법입니다.
0.54.22,Why? because we're asking the blockchain  which is a very slow system  to compute a square root  when we could do something much simpler.,왜냐면 블록체인은 느리고  그런 느린 시스템에 제곱근을 계산하도록 요청했기 때문입니다. 체인 상에서는 훨씬 더 간단한 것들이 수행되어야 합니다.
0.54.31,So the right way of doing this is to actually compute square root outside of the blockchain and ask the blockchain to double-check that the square root is computed property.,그래서 - 올바른 방법은  제곱근은 체인 밖에서 계산하고  블록체인을 이용해서 제곱근이 잘 계산되었는지 증명할 수 있습니다.
0.54.42,So that would mean that here  the application  it would call the contract on the blockchain with 9 and a square root of 9 which is 3  and the only thing that the blockchain does is that it checks that 3*3 equals 9  and then uses the value of 3.,다시 말하면 컨트랙트 요청을 할 때 9와 9의 제곱근인 3을 같이 인자로 요청하고  블록체인은 역으로 3*3 = 9가 나오는지 확인한 뒤  값이 맞다면 최종 값 3을 사용하면 됩니다.
0.54.58,The difference is that in one case  you're computing square roots in the blockchain  with the virtual macihne of the blockchain  which is extremely slow. In the other case you're just computing multiplication and checking that the values are equal.,차이점은 첫번째 예제에서는 제곱근 계산을 굉장히 느린 부분인 블록체인의 가상머신에서 수행하고 있고  두번째 예제에서는 단순한 곱셈 연산만을 수행하고 값이 같은지 체크합니다.
0.55.12,So this is the right way of doing a contract  pushing everything that can be pushed outside of the blockchain outside  and just do the minimal verifications into blockchain  and this is the wrong way of doing a contract which is to make the blockchain compute things that could be computed elsewhere.,이것이 바로 올바른 방법입니다. 체인 밖에서 계산 될 수 있는 모든것들은 체인 밖으로 내보내고  블록체인 상에서는 최소한의 검증만 하는 것이고  잘못된 방법은 블록체인이 복잡한 계산을 하게 하는 것이죠
0.55.32,So Tezos encourages pushing outside of the blockchain as many computations as you can.,그래서 테조스는 최대한 많은 연산을 체인 밖으로 빼기를 권장합니다.
0.55.45,Again in the languages how the language ecosystem works  how the language stack works. Here you have different languages  these are different languages that compile to Michelson.,언어: 언어 생태계와 구성에 대해 설명하겠습니다. 여기 다른 언어들이 있는데  이 언어들은 모두 미켈슨으로 컴파일 되는 언어들입니다.
0.56.02, and all those are prototype languages  and the compilers are not finished  but in this case there is mini OCaml  mini Haskell  mini JavaScript and mini Python. And they compile to Michelson.,아직 초기 상태의 언어들이고 컴파일러도 완성되지 않았지만 어쨌든 mini OCaml  mini Haskell  mini Javascript 그리고 mini Python이 있습니다. 이 언어들은 모두 미켈슨으로 컴파일 됩니다.
0.56.13,For the moment there are 4 separate compilers. In the future they are going to be DSLs as well. The global problem here is that all this compilation needs to first understand the cost model of blockchain.,지금 현재로써는 4개의 별도 컴파일러가 있고요. 향후에는 DSL도 추가 될 예정입니다. 전체적인 문제가 있다면 이 모든 컴파일 단계가 블록체인의 비용 모델을 이해해야 한다는 점입니다.
0.56.27,The fact that for blockchain you have to pay for the memory  you have to pay for a instructions  and the fact that you should push all the computations that you can outside of the blockchain.,블록체인에서 비용은 메모리  절차 수행에 의해 발생됩니다. (그렇기 때문에 더더욱 복잡한 계산은 체인 밖으로 빼야겠죠?)
0.56.36,It should also incorporate all these formal verification techniques; model checking  abstract interpretation  theorem provers ,또한 형식검증도 수행해야 하고  model checking  abstract interpretation  theorem provers 등…
0.56.45, and ideally all these compilers should be certified in such a way that the program that is written in the upper language is proven equivalent to the program that is executed by Michelson.,상위언어로 작성한 이 모든 측면이 미켈슨으로 짠 코드와 같아지도록 컴파일러가 인증되고 검증되어야 합니다.
0.56.59,So here is one compilation system works inside of the blockchain  in Tezos.,테조스의 컴파일 시스템이 어떻게 작동하는지 보셨습니다.
0.57.08,The challenges. so the challenges of this language layer or to make sure that the programs that are in the blockchain correspond to what users expect.,숙제들입니다. 언어 레이어의 숙제는 체인상의 프로그램들이 사용자의 기대와 일치하도록 만드는 것입니다.
0.57.19,remember that users will use programs that are already in the blockchain that were put there by other people  by 3rd parties. and it's very important for them to be able to be convinced to be sure that those programs are not malicious,앞서 얘기한 사용자는 대부분의 시간을 제3자가 작성한 코드를 사용한단 말 기억하시나요? 그렇기 때문에 사용자는 이 프로그램을 사용하는것이 안전한지  악의적인 코드는 아닌지 알아야만 합니다.
0.57.38,so this is probably the most important challenge in the language layer. Making sure that the users understand the semantics  the meaning of the contracts that they're using. Whether they were really written by them or written by other people,언어 레이어에서는 이런 부분이 아마 가장 어렵지 않을까 싶습니다. 사용자들이 언어 체계를 이해하게 만드는  사용자들이 사용하는 컨트랙트의 내용이 무엇인지 이해하게끔 만드는 것 말이죠. 직접 쓴 컨트랙트이던 제3자가 썼던간에요.
0.57.59,The second challenge is to be able to  on those contracts  prove contract-specific properties. Third challenge is to to certify the a compilation system end-to-end. After that to design DSL (domain specific language) for specific type of contracts that are going to make the design of this type of contracts easier.,두번째 숙제는 컨트랙트 마다 특정되는 속성들을 검증하는 것입니다. 세번째로는 컴파일 시스템을 e2e로 검증하는 일일테고요. 그 다음엔 특정 컨트랙트 분류마다의 DSL입니다.
0.58.20,So DSLs could be things like a specific languages for financial contracts  a specific language for contracts between simple contracts. All types of specific languages.,예를들면 금융거래를 위한 DSL  혹은 간단한 계약 관계를 위한 DSL등  뭐든지 있을 수 있습니다.
0.58.38,And another challenge is to design programming environments that help developers program for the blockchain  and understand the cost model the blockchain.,다른 어려운점은 개발자들이 블록체인 개발을 할 수 있는 환경을 만들고  블록체인의 비용 모델을 이해하게끔 하는 일입니다.
0.58.48,The blockchain is an environment in which programming is a little bit different than what most developers are used to,블록체인은 다른 프로그래머들이 일반적으로 익숙한 분야와는 조금 다른 분야입니다.
0.58.56,There are costs for the operations  there is a cost for memory usage  and this complex thing between what to put in the blockchain and what to put outside of the blockchain.,운영 비용이 다르겠죠 - 메모리  체인에서 계산해야 할지 밖으로 빼야할지 등등등.
0.59.04,so if we can have environments that help programmers do a better job at programming their contracts that would be very useful.,그래서 만약 개발자들이 이런 결정을 쉽게 할 수 있는 개발 환경이 있고 이를 통해 컨트랙트 작성이 쉬워진다면 좋을것입니다.
0.59.16,Next element. All this we said that blockchains needed to have financial grade security. And financial grade security is most of the time supported by cryptography.,다음입니다. 앞서 블록체인은 금융 시스템에 버금가는 보안 수준을 갖춰야 한다고 했습니다. 이 보안의 많은 부분은 암호로 이루어져 있습니다.
0.59.32,Tezos already uses certified cryptography  which means that this cryptographic primitives do not have bugs or do not have certain types of bugs ,테조스는 검증된 암호화 체계를 사용합니다. 그렇기 때문에 암호학적 산출물이 버그나 다른 문제를 야기하지 않습니다.
0.59.42,because they have already been proven correct according to a given specification  in this case we use a library that is written in F*.,테조스가 사용하는 암호 체계는 필요한 요구사항에 대해 F*등의 툴로 이미 검증이 되었습니다.
0.59.52,Another part of financial system security is to be able to do anonymous transactions and also to interoperate with other systems.,보안의 다른 부분은 무기명 송금을 하면서도 다른 외부 시스템과 상호작용하는 것입니다.
1.00.04,and the interoperability with other systems is guaranteed by something that is named zero-knowledge proofs,이러한 외부 시스템과의 상호작용은 zero-knowledge proofs라는 것으로 동작이 보장됩니다.
1.00.10,Zero knowledge proofs  it's a little bit complicated. It’s the fact that you are able to prove to someone else that you did something without telling them any details.,Zero knowledge proof는 설명하기 조금 까다롭습니다. 마치 여러분이 저에게 아무 디테일도 말하지 않고 무언가 했다고 증명하는 것입니다.
1.00.30,So it’s the proof that I did a computation  the proof that I took some money. It’s like when you have your Visa cards. Your Visa card and you use your Visa card to do to pay things  and at the end of you would like the Visa vendor to prove to you ,연산을 했다는 증명  혹은 돈을 좀 썼는지 따위의 증명이 있죠. Visa카드를 생각해봅시다. 여러분은 Visa 카드를 사용해서 물건값을 지불합니다. Visa가 여러분의 계좌에서 돈을 가져갈 때  여러분이 실제로 사용한 카드 사용분 만큼 정확한 계산을 해서 돈을 가져갔음을 증명할 수 있습니다.
1.00.51, that they have taken all the transactions into consideration that the sum of all the transactions is what they're taking out of from your bank account.,
1.00.59,In such a way that there is only one of each and that you really did all of those. In such a way that you can have the guarantee that this value is correct.,
1.01.08,Now that’s the proof side and if a Visa System  as a credit card system  is going to interact with blockchain  then the proof needs to be opaque in the sense that your credit card vendor doesn't want to give information about what were the type of transactions you have done  who are the customers etc.,여기까지는 Visa의 증명 시스템에 관한 내용입니다. 만약 Visa 시스템이 블록체인와 상호작용해야 한다면  이 증명들에서 중요한 정보는 가려져야 할것입니다. Visa사는 블록체인에 거래의 종류나 누구의 거래인지 등등의 정보를 남기고 싶지 않을테니까요.
1.01.33,so they need to prove that they did the counting properly without showing the details of the transaction that it took into account. That’s the idea of the zero knowledge proofs. ,Visa는 그런 정보를 주지 않고도 셈을 잘 했다고 증명할 수 있어야 합니다. 이것이Zero knowledge proof입니다.
1.01.43,Current state-of-the-art is a SNARKs  STARKs  and there are many variants of them. What is important is that those things are still very early research.,최근 기술로는 SNARKs  STARKs등이 있고 다른 많은 유형들이 있습니다. 중요한점은 zero knowledge proof는 아직 연구의 초기단계라는 점입니다.
1.01.56,The state-of-the-art  those things are very complex mathematical systems. They are very research consuming  you need a lot of computing power to make them work especially for the most advanced type of computation,여기 나온 최첨단 기술들은 수학적으로 엄청나게 복잡한 시스템입니다. 이것들이 제대로 작동하게 하기 위해서는 많은 연구와 컴퓨팅 파워가 필요합니다.
1.02.10,So this is yet  still a research which is going on.,네 그래서... 아직은 연구중인 부분입니다.
1.02.17,But this type of cryptography is the one that allows interoperation between blockchains and existing financial systems. Safe interoperation.,블록체인과 다른 금융 시스템과의 안전한 연계는 이런 암호체계를 통해 이루어집니다.
1.02.29,You can always connect them but if you want to connect them you want the system to be as secure as the blockchain  so you don't want the bank to actually be a vector attack for free or blockchain.,연결은 언제든지 할 수 있겠지만  만약 진짜 연결을 한다면 대상 금융 시스템이 블록체인 만큼 안전해야 할 것입니다. 그렇지 않으면 또 다른 공격의 거점이 되니까요.
1.02.43,so this is the purpose  the usage of zero-knowledge proofs  and there is also a challenge  so the challenge in zero-knowledge proofs on cryptography are the fact that we would like a end-to-end certified zero-knowledge proofs.,Zero-knowledge proof는 이런 용도로 사용됩니다. Zero-knowledge proof의 숙제는 양 단간 보증 된 zero-knowledge proof를 만드는 것일겁니다.
1.02.59,and the other thing is that the zero knowledge proofs that we have today are generic. Because they are generic they're very complex.,다른 숙제로는 오늘날의 zero knowledge proof는 보편적이기 때문에 굉장히 복잡한 특성을 나타냅니다.
1.03.07,It would be useful to have domain specific zero knowledge proofs  that hopefully would be more efficient to compute and simple. But they would only do simplified things. but ideally more efficient type of zero knowledge proofs,도메인별로 특화 된 zero knowledge proof가 있으면  필요한 연산이 훨씬 효율적이고 간단할 것입니다. 아주 간단한 zero knowledge proof정도만 수행 하겠지만요. 이상적으로는 효율적인 zero knowledge proof가 더 좋은 방법입니다.
1.03.16,So all those are open challenges. These are research questions we don't have the answer to these problems  in particular the ones on zero-knowledge proofs,이 모든것들이 다 숙제로 남아있습니다. 이 숙제들은 연구적 가치가 있는 질문들이지만 아직 답은 찾지 못했습니다. 특히 zero knowledge proofs에 관해서는 말이죠.
